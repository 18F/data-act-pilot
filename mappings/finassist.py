#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated  by generateDS.py.
#
# Command line options:
#   ('-o', 'finassist.py')
#   ('-q', '')
#   ('-f', '')
#   ('--no-dates', '')
#   ('--no-versions', '')
#
# Command line arguments:
#   ../schema/xbrl/finassist/da-finassist-content-2015-06-29.xsd
#
# Command line:
#   /Users/rebeccasweger/Dev/.virtualenvs/intercessor/lib/python2.7/site-packages/generateDS-2.17a0/generateDS.py -o "finassist.py" -q -f --no-dates --no-versions ../schema/xbrl/finassist/da-finassist-content-2015-06-29.xsd
#
# Current working directory (os.getcwd()):
#   mappings
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class awardComplexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, awardDescription=None, awardID=None, parentAwardID=None, modificationAmendmentNumber=None, recordType=None, typeOfAction=None, typeOfTransactionCode=None, awardeeInformation=None, primaryPlaceOfPerformance=None, periodOfPerformance=None, awardingAgency=None, fundingAgency=None, awardingSubTierAgency=None, fundingSubTierAgency=None, highlyCompensatedOfficer=None, catalogOfFederalDomesticAssistanceProgram=None, awardAmounts=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.awardDescription = awardDescription
        self.awardID = awardID
        self.parentAwardID = parentAwardID
        self.modificationAmendmentNumber = modificationAmendmentNumber
        self.recordType = recordType
        self.typeOfAction = typeOfAction
        self.typeOfTransactionCode = typeOfTransactionCode
        self.awardeeInformation = awardeeInformation
        self.primaryPlaceOfPerformance = primaryPlaceOfPerformance
        self.periodOfPerformance = periodOfPerformance
        if awardingAgency is None:
            self.awardingAgency = []
        else:
            self.awardingAgency = awardingAgency
        if fundingAgency is None:
            self.fundingAgency = []
        else:
            self.fundingAgency = fundingAgency
        if awardingSubTierAgency is None:
            self.awardingSubTierAgency = []
        else:
            self.awardingSubTierAgency = awardingSubTierAgency
        if fundingSubTierAgency is None:
            self.fundingSubTierAgency = []
        else:
            self.fundingSubTierAgency = fundingSubTierAgency
        if highlyCompensatedOfficer is None:
            self.highlyCompensatedOfficer = []
        else:
            self.highlyCompensatedOfficer = highlyCompensatedOfficer
        self.catalogOfFederalDomesticAssistanceProgram = catalogOfFederalDomesticAssistanceProgram
        self.awardAmounts = awardAmounts
    def factory(*args_, **kwargs_):
        if awardComplexType.subclass:
            return awardComplexType.subclass(*args_, **kwargs_)
        else:
            return awardComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_awardDescription(self): return self.awardDescription
    def set_awardDescription(self, awardDescription): self.awardDescription = awardDescription
    def get_awardID(self): return self.awardID
    def set_awardID(self, awardID): self.awardID = awardID
    def get_parentAwardID(self): return self.parentAwardID
    def set_parentAwardID(self, parentAwardID): self.parentAwardID = parentAwardID
    def get_modificationAmendmentNumber(self): return self.modificationAmendmentNumber
    def set_modificationAmendmentNumber(self, modificationAmendmentNumber): self.modificationAmendmentNumber = modificationAmendmentNumber
    def get_recordType(self): return self.recordType
    def set_recordType(self, recordType): self.recordType = recordType
    def get_typeOfAction(self): return self.typeOfAction
    def set_typeOfAction(self, typeOfAction): self.typeOfAction = typeOfAction
    def get_typeOfTransactionCode(self): return self.typeOfTransactionCode
    def set_typeOfTransactionCode(self, typeOfTransactionCode): self.typeOfTransactionCode = typeOfTransactionCode
    def get_awardeeInformation(self): return self.awardeeInformation
    def set_awardeeInformation(self, awardeeInformation): self.awardeeInformation = awardeeInformation
    def get_primaryPlaceOfPerformance(self): return self.primaryPlaceOfPerformance
    def set_primaryPlaceOfPerformance(self, primaryPlaceOfPerformance): self.primaryPlaceOfPerformance = primaryPlaceOfPerformance
    def get_periodOfPerformance(self): return self.periodOfPerformance
    def set_periodOfPerformance(self, periodOfPerformance): self.periodOfPerformance = periodOfPerformance
    def get_awardingAgency(self): return self.awardingAgency
    def set_awardingAgency(self, awardingAgency): self.awardingAgency = awardingAgency
    def add_awardingAgency(self, value): self.awardingAgency.append(value)
    def insert_awardingAgency_at(self, index, value): self.awardingAgency.insert(index, value)
    def replace_awardingAgency_at(self, index, value): self.awardingAgency[index] = value
    def get_fundingAgency(self): return self.fundingAgency
    def set_fundingAgency(self, fundingAgency): self.fundingAgency = fundingAgency
    def add_fundingAgency(self, value): self.fundingAgency.append(value)
    def insert_fundingAgency_at(self, index, value): self.fundingAgency.insert(index, value)
    def replace_fundingAgency_at(self, index, value): self.fundingAgency[index] = value
    def get_awardingSubTierAgency(self): return self.awardingSubTierAgency
    def set_awardingSubTierAgency(self, awardingSubTierAgency): self.awardingSubTierAgency = awardingSubTierAgency
    def add_awardingSubTierAgency(self, value): self.awardingSubTierAgency.append(value)
    def insert_awardingSubTierAgency_at(self, index, value): self.awardingSubTierAgency.insert(index, value)
    def replace_awardingSubTierAgency_at(self, index, value): self.awardingSubTierAgency[index] = value
    def get_fundingSubTierAgency(self): return self.fundingSubTierAgency
    def set_fundingSubTierAgency(self, fundingSubTierAgency): self.fundingSubTierAgency = fundingSubTierAgency
    def add_fundingSubTierAgency(self, value): self.fundingSubTierAgency.append(value)
    def insert_fundingSubTierAgency_at(self, index, value): self.fundingSubTierAgency.insert(index, value)
    def replace_fundingSubTierAgency_at(self, index, value): self.fundingSubTierAgency[index] = value
    def get_highlyCompensatedOfficer(self): return self.highlyCompensatedOfficer
    def set_highlyCompensatedOfficer(self, highlyCompensatedOfficer): self.highlyCompensatedOfficer = highlyCompensatedOfficer
    def add_highlyCompensatedOfficer(self, value): self.highlyCompensatedOfficer.append(value)
    def insert_highlyCompensatedOfficer_at(self, index, value): self.highlyCompensatedOfficer.insert(index, value)
    def replace_highlyCompensatedOfficer_at(self, index, value): self.highlyCompensatedOfficer[index] = value
    def get_catalogOfFederalDomesticAssistanceProgram(self): return self.catalogOfFederalDomesticAssistanceProgram
    def set_catalogOfFederalDomesticAssistanceProgram(self, catalogOfFederalDomesticAssistanceProgram): self.catalogOfFederalDomesticAssistanceProgram = catalogOfFederalDomesticAssistanceProgram
    def get_awardAmounts(self): return self.awardAmounts
    def set_awardAmounts(self, awardAmounts): self.awardAmounts = awardAmounts
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.awardDescription is not None or
            self.awardID is not None or
            self.parentAwardID is not None or
            self.modificationAmendmentNumber is not None or
            self.recordType is not None or
            self.typeOfAction is not None or
            self.typeOfTransactionCode is not None or
            self.awardeeInformation is not None or
            self.primaryPlaceOfPerformance is not None or
            self.periodOfPerformance is not None or
            self.awardingAgency or
            self.fundingAgency or
            self.awardingSubTierAgency or
            self.fundingSubTierAgency or
            self.highlyCompensatedOfficer or
            self.catalogOfFederalDomesticAssistanceProgram is not None or
            self.awardAmounts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='awardComplexType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:award="http://www.xbrl.org/int/award/2006-10-25"  xmlns:gen="http://www.xbrl.org/int/gl/gen/2006-10-25" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='awardComplexType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='awardComplexType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='awardComplexType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='awardComplexType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.awardDescription is not None:
            self.awardDescription.export(outfile, level, namespace_='award:', name_='awardDescription', pretty_print=pretty_print)
        if self.awardID is not None:
            self.awardID.export(outfile, level, namespace_='gen:', name_='awardID', pretty_print=pretty_print)
        if self.parentAwardID is not None:
            self.parentAwardID.export(outfile, level, namespace_='award:', name_='parentAwardID', pretty_print=pretty_print)
        if self.modificationAmendmentNumber is not None:
            self.modificationAmendmentNumber.export(outfile, level, namespace_='award:', name_='modificationAmendmentNumber', pretty_print=pretty_print)
        if self.recordType is not None:
            self.recordType.export(outfile, level, namespace_='award:', name_='recordType', pretty_print=pretty_print)
        if self.typeOfAction is not None:
            self.typeOfAction.export(outfile, level, namespace_='award:', name_='typeOfAction', pretty_print=pretty_print)
        if self.typeOfTransactionCode is not None:
            self.typeOfTransactionCode.export(outfile, level, namespace_='award:', name_='typeOfTransactionCode', pretty_print=pretty_print)
        if self.awardeeInformation is not None:
            self.awardeeInformation.export(outfile, level, namespace_='finassist:', name_='awardeeInformation', pretty_print=pretty_print)
        if self.primaryPlaceOfPerformance is not None:
            self.primaryPlaceOfPerformance.export(outfile, level, namespace_='award:', name_='primaryPlaceOfPerformance', pretty_print=pretty_print)
        if self.periodOfPerformance is not None:
            self.periodOfPerformance.export(outfile, level, namespace_='finassist:', name_='periodOfPerformance', pretty_print=pretty_print)
        for awardingAgency_ in self.awardingAgency:
            awardingAgency_.export(outfile, level, namespace_='award:', name_='awardingAgency', pretty_print=pretty_print)
        for fundingAgency_ in self.fundingAgency:
            fundingAgency_.export(outfile, level, namespace_='award:', name_='fundingAgency', pretty_print=pretty_print)
        for awardingSubTierAgency_ in self.awardingSubTierAgency:
            awardingSubTierAgency_.export(outfile, level, namespace_='award:', name_='awardingSubTierAgency', pretty_print=pretty_print)
        for fundingSubTierAgency_ in self.fundingSubTierAgency:
            fundingSubTierAgency_.export(outfile, level, namespace_='award:', name_='fundingSubTierAgency', pretty_print=pretty_print)
        for highlyCompensatedOfficer_ in self.highlyCompensatedOfficer:
            highlyCompensatedOfficer_.export(outfile, level, namespace_='award:', name_='highlyCompensatedOfficer', pretty_print=pretty_print)
        if self.catalogOfFederalDomesticAssistanceProgram is not None:
            self.catalogOfFederalDomesticAssistanceProgram.export(outfile, level, namespace_='finassist:', name_='catalogOfFederalDomesticAssistanceProgram', pretty_print=pretty_print)
        if self.awardAmounts is not None:
            self.awardAmounts.export(outfile, level, namespace_='finassist:', name_='awardAmounts', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'awardDescription':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.awardDescription = obj_
            obj_.original_tagname_ = 'awardDescription'
        elif nodeName_ == 'awardID':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.awardID = obj_
            obj_.original_tagname_ = 'awardID'
        elif nodeName_ == 'parentAwardID':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.parentAwardID = obj_
            obj_.original_tagname_ = 'parentAwardID'
        elif nodeName_ == 'modificationAmendmentNumber':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.modificationAmendmentNumber = obj_
            obj_.original_tagname_ = 'modificationAmendmentNumber'
        elif nodeName_ == 'recordType':
            obj_ = recordTypeItemType.factory()
            obj_.build(child_)
            self.recordType = obj_
            obj_.original_tagname_ = 'recordType'
        elif nodeName_ == 'typeOfAction':
            obj_ = typeOfActionItemType.factory()
            obj_.build(child_)
            self.typeOfAction = obj_
            obj_.original_tagname_ = 'typeOfAction'
        elif nodeName_ == 'typeOfTransactionCode':
            obj_ = typeOfTransactionCodeItemType.factory()
            obj_.build(child_)
            self.typeOfTransactionCode = obj_
            obj_.original_tagname_ = 'typeOfTransactionCode'
        elif nodeName_ == 'awardeeInformation':
            obj_ = awardeeInformationComplexType.factory()
            obj_.build(child_)
            self.awardeeInformation = obj_
            obj_.original_tagname_ = 'awardeeInformation'
        elif nodeName_ == 'primaryPlaceOfPerformance':
            obj_ = addressComplexType.factory()
            obj_.build(child_)
            self.primaryPlaceOfPerformance = obj_
            obj_.original_tagname_ = 'primaryPlaceOfPerformance'
        elif nodeName_ == 'periodOfPerformance':
            obj_ = periodOfPerformanceComplexType.factory()
            obj_.build(child_)
            self.periodOfPerformance = obj_
            obj_.original_tagname_ = 'periodOfPerformance'
        elif nodeName_ == 'awardingAgency':
            obj_ = agencyComplexType.factory()
            obj_.build(child_)
            self.awardingAgency.append(obj_)
            obj_.original_tagname_ = 'awardingAgency'
        elif nodeName_ == 'fundingAgency':
            obj_ = agencyComplexType.factory()
            obj_.build(child_)
            self.fundingAgency.append(obj_)
            obj_.original_tagname_ = 'fundingAgency'
        elif nodeName_ == 'awardingSubTierAgency':
            obj_ = agencyComplexType.factory()
            obj_.build(child_)
            self.awardingSubTierAgency.append(obj_)
            obj_.original_tagname_ = 'awardingSubTierAgency'
        elif nodeName_ == 'fundingSubTierAgency':
            obj_ = agencyComplexType.factory()
            obj_.build(child_)
            self.fundingSubTierAgency.append(obj_)
            obj_.original_tagname_ = 'fundingSubTierAgency'
        elif nodeName_ == 'highlyCompensatedOfficer':
            obj_ = highlyCompensatedOfficerComplexType.factory()
            obj_.build(child_)
            self.highlyCompensatedOfficer.append(obj_)
            obj_.original_tagname_ = 'highlyCompensatedOfficer'
        elif nodeName_ == 'catalogOfFederalDomesticAssistanceProgram':
            obj_ = catalogOfFederalDomesticAssistanceProgramComplexType.factory()
            obj_.build(child_)
            self.catalogOfFederalDomesticAssistanceProgram = obj_
            obj_.original_tagname_ = 'catalogOfFederalDomesticAssistanceProgram'
        elif nodeName_ == 'awardAmounts':
            obj_ = awardAmountsComplexType.factory()
            obj_.build(child_)
            self.awardAmounts = obj_
            obj_.original_tagname_ = 'awardAmounts'
# end class awardComplexType


class catalogOfFederalDomesticAssistanceProgramComplexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, catalogOfFederalDomesticAssistanceTitle=None, catalogOfFederalDomesticAssistanceNumber=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.catalogOfFederalDomesticAssistanceTitle = catalogOfFederalDomesticAssistanceTitle
        self.catalogOfFederalDomesticAssistanceNumber = catalogOfFederalDomesticAssistanceNumber
    def factory(*args_, **kwargs_):
        if catalogOfFederalDomesticAssistanceProgramComplexType.subclass:
            return catalogOfFederalDomesticAssistanceProgramComplexType.subclass(*args_, **kwargs_)
        else:
            return catalogOfFederalDomesticAssistanceProgramComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_catalogOfFederalDomesticAssistanceTitle(self): return self.catalogOfFederalDomesticAssistanceTitle
    def set_catalogOfFederalDomesticAssistanceTitle(self, catalogOfFederalDomesticAssistanceTitle): self.catalogOfFederalDomesticAssistanceTitle = catalogOfFederalDomesticAssistanceTitle
    def get_catalogOfFederalDomesticAssistanceNumber(self): return self.catalogOfFederalDomesticAssistanceNumber
    def set_catalogOfFederalDomesticAssistanceNumber(self, catalogOfFederalDomesticAssistanceNumber): self.catalogOfFederalDomesticAssistanceNumber = catalogOfFederalDomesticAssistanceNumber
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.catalogOfFederalDomesticAssistanceTitle is not None or
            self.catalogOfFederalDomesticAssistanceNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='catalogOfFederalDomesticAssistanceProgramComplexType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='catalogOfFederalDomesticAssistanceProgramComplexType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='catalogOfFederalDomesticAssistanceProgramComplexType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='catalogOfFederalDomesticAssistanceProgramComplexType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='catalogOfFederalDomesticAssistanceProgramComplexType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.catalogOfFederalDomesticAssistanceTitle is not None:
            self.catalogOfFederalDomesticAssistanceTitle.export(outfile, level, namespace_='finassist:', name_='catalogOfFederalDomesticAssistanceTitle', pretty_print=pretty_print)
        if self.catalogOfFederalDomesticAssistanceNumber is not None:
            self.catalogOfFederalDomesticAssistanceNumber.export(outfile, level, namespace_='finassist:', name_='catalogOfFederalDomesticAssistanceNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'catalogOfFederalDomesticAssistanceTitle':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.catalogOfFederalDomesticAssistanceTitle = obj_
            obj_.original_tagname_ = 'catalogOfFederalDomesticAssistanceTitle'
        elif nodeName_ == 'catalogOfFederalDomesticAssistanceNumber':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.catalogOfFederalDomesticAssistanceNumber = obj_
            obj_.original_tagname_ = 'catalogOfFederalDomesticAssistanceNumber'
# end class catalogOfFederalDomesticAssistanceProgramComplexType


class awardAmountsComplexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, federalFundingAmount=None, totalFundingAmount=None, nonFederalFundingAmount=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.federalFundingAmount = federalFundingAmount
        self.totalFundingAmount = totalFundingAmount
        self.nonFederalFundingAmount = nonFederalFundingAmount
    def factory(*args_, **kwargs_):
        if awardAmountsComplexType.subclass:
            return awardAmountsComplexType.subclass(*args_, **kwargs_)
        else:
            return awardAmountsComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_federalFundingAmount(self): return self.federalFundingAmount
    def set_federalFundingAmount(self, federalFundingAmount): self.federalFundingAmount = federalFundingAmount
    def get_totalFundingAmount(self): return self.totalFundingAmount
    def set_totalFundingAmount(self, totalFundingAmount): self.totalFundingAmount = totalFundingAmount
    def get_nonFederalFundingAmount(self): return self.nonFederalFundingAmount
    def set_nonFederalFundingAmount(self, nonFederalFundingAmount): self.nonFederalFundingAmount = nonFederalFundingAmount
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.federalFundingAmount is not None or
            self.totalFundingAmount is not None or
            self.nonFederalFundingAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='awardAmountsComplexType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:award="http://www.xbrl.org/int/award/2006-10-25" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='awardAmountsComplexType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='awardAmountsComplexType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='awardAmountsComplexType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='awardAmountsComplexType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.federalFundingAmount is not None:
            self.federalFundingAmount.export(outfile, level, namespace_='award:', name_='federalFundingAmount', pretty_print=pretty_print)
        if self.totalFundingAmount is not None:
            self.totalFundingAmount.export(outfile, level, namespace_='finassist:', name_='totalFundingAmount', pretty_print=pretty_print)
        if self.nonFederalFundingAmount is not None:
            self.nonFederalFundingAmount.export(outfile, level, namespace_='finassist:', name_='nonFederalFundingAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'federalFundingAmount':
            obj_ = amountItemType.factory()
            obj_.build(child_)
            self.federalFundingAmount = obj_
            obj_.original_tagname_ = 'federalFundingAmount'
        elif nodeName_ == 'totalFundingAmount':
            obj_ = amountItemType.factory()
            obj_.build(child_)
            self.totalFundingAmount = obj_
            obj_.original_tagname_ = 'totalFundingAmount'
        elif nodeName_ == 'nonFederalFundingAmount':
            obj_ = amountItemType.factory()
            obj_.build(child_)
            self.nonFederalFundingAmount = obj_
            obj_.original_tagname_ = 'nonFederalFundingAmount'
# end class awardAmountsComplexType


class awardeeInformationComplexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, businessType=None, awardeeLegalBusinessName=None, ultimateParentUniqueIdentifier=None, awardeeUniqueIdentifier=None, awardeeUniqueIdentifierSupplemental=None, ultimateParentLegalBusinessName=None, awardeeAddress=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.businessType = businessType
        self.awardeeLegalBusinessName = awardeeLegalBusinessName
        self.ultimateParentUniqueIdentifier = ultimateParentUniqueIdentifier
        self.awardeeUniqueIdentifier = awardeeUniqueIdentifier
        self.awardeeUniqueIdentifierSupplemental = awardeeUniqueIdentifierSupplemental
        self.ultimateParentLegalBusinessName = ultimateParentLegalBusinessName
        self.awardeeAddress = awardeeAddress
    def factory(*args_, **kwargs_):
        if awardeeInformationComplexType.subclass:
            return awardeeInformationComplexType.subclass(*args_, **kwargs_)
        else:
            return awardeeInformationComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessType(self): return self.businessType
    def set_businessType(self, businessType): self.businessType = businessType
    def get_awardeeLegalBusinessName(self): return self.awardeeLegalBusinessName
    def set_awardeeLegalBusinessName(self, awardeeLegalBusinessName): self.awardeeLegalBusinessName = awardeeLegalBusinessName
    def get_ultimateParentUniqueIdentifier(self): return self.ultimateParentUniqueIdentifier
    def set_ultimateParentUniqueIdentifier(self, ultimateParentUniqueIdentifier): self.ultimateParentUniqueIdentifier = ultimateParentUniqueIdentifier
    def get_awardeeUniqueIdentifier(self): return self.awardeeUniqueIdentifier
    def set_awardeeUniqueIdentifier(self, awardeeUniqueIdentifier): self.awardeeUniqueIdentifier = awardeeUniqueIdentifier
    def get_awardeeUniqueIdentifierSupplemental(self): return self.awardeeUniqueIdentifierSupplemental
    def set_awardeeUniqueIdentifierSupplemental(self, awardeeUniqueIdentifierSupplemental): self.awardeeUniqueIdentifierSupplemental = awardeeUniqueIdentifierSupplemental
    def get_ultimateParentLegalBusinessName(self): return self.ultimateParentLegalBusinessName
    def set_ultimateParentLegalBusinessName(self, ultimateParentLegalBusinessName): self.ultimateParentLegalBusinessName = ultimateParentLegalBusinessName
    def get_awardeeAddress(self): return self.awardeeAddress
    def set_awardeeAddress(self, awardeeAddress): self.awardeeAddress = awardeeAddress
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.businessType is not None or
            self.awardeeLegalBusinessName is not None or
            self.ultimateParentUniqueIdentifier is not None or
            self.awardeeUniqueIdentifier is not None or
            self.awardeeUniqueIdentifierSupplemental is not None or
            self.ultimateParentLegalBusinessName is not None or
            self.awardeeAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='awardeeInformationComplexType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:award="http://www.xbrl.org/int/award/2006-10-25" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='awardeeInformationComplexType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='awardeeInformationComplexType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='awardeeInformationComplexType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='awardeeInformationComplexType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessType is not None:
            self.businessType.export(outfile, level, namespace_='award:', name_='businessType', pretty_print=pretty_print)
        if self.awardeeLegalBusinessName is not None:
            self.awardeeLegalBusinessName.export(outfile, level, namespace_='award:', name_='awardeeLegalBusinessName', pretty_print=pretty_print)
        if self.ultimateParentUniqueIdentifier is not None:
            self.ultimateParentUniqueIdentifier.export(outfile, level, namespace_='award:', name_='ultimateParentUniqueIdentifier', pretty_print=pretty_print)
        if self.awardeeUniqueIdentifier is not None:
            self.awardeeUniqueIdentifier.export(outfile, level, namespace_='award:', name_='awardeeUniqueIdentifier', pretty_print=pretty_print)
        if self.awardeeUniqueIdentifierSupplemental is not None:
            self.awardeeUniqueIdentifierSupplemental.export(outfile, level, namespace_='award:', name_='awardeeUniqueIdentifierSupplemental', pretty_print=pretty_print)
        if self.ultimateParentLegalBusinessName is not None:
            self.ultimateParentLegalBusinessName.export(outfile, level, namespace_='award:', name_='ultimateParentLegalBusinessName', pretty_print=pretty_print)
        if self.awardeeAddress is not None:
            self.awardeeAddress.export(outfile, level, namespace_='award:', name_='awardeeAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessType':
            obj_ = businessTypeItemType.factory()
            obj_.build(child_)
            self.businessType = obj_
            obj_.original_tagname_ = 'businessType'
        elif nodeName_ == 'awardeeLegalBusinessName':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.awardeeLegalBusinessName = obj_
            obj_.original_tagname_ = 'awardeeLegalBusinessName'
        elif nodeName_ == 'ultimateParentUniqueIdentifier':
            obj_ = integerItemType.factory()
            obj_.build(child_)
            self.ultimateParentUniqueIdentifier = obj_
            obj_.original_tagname_ = 'ultimateParentUniqueIdentifier'
        elif nodeName_ == 'awardeeUniqueIdentifier':
            obj_ = integerItemType.factory()
            obj_.build(child_)
            self.awardeeUniqueIdentifier = obj_
            obj_.original_tagname_ = 'awardeeUniqueIdentifier'
        elif nodeName_ == 'awardeeUniqueIdentifierSupplemental':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.awardeeUniqueIdentifierSupplemental = obj_
            obj_.original_tagname_ = 'awardeeUniqueIdentifierSupplemental'
        elif nodeName_ == 'ultimateParentLegalBusinessName':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.ultimateParentLegalBusinessName = obj_
            obj_.original_tagname_ = 'ultimateParentLegalBusinessName'
        elif nodeName_ == 'awardeeAddress':
            obj_ = addressComplexType.factory()
            obj_.build(child_)
            self.awardeeAddress = obj_
            obj_.original_tagname_ = 'awardeeAddress'
# end class awardeeInformationComplexType


class periodOfPerformanceComplexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, periodOfPerformanceActionDate=None, periodOfPerformanceStartDate=None, periodOfPerformanceCurrentEndDate=None, periodOfPerformancePotentialEndDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.periodOfPerformanceActionDate = periodOfPerformanceActionDate
        self.periodOfPerformanceStartDate = periodOfPerformanceStartDate
        self.periodOfPerformanceCurrentEndDate = periodOfPerformanceCurrentEndDate
        self.periodOfPerformancePotentialEndDate = periodOfPerformancePotentialEndDate
    def factory(*args_, **kwargs_):
        if periodOfPerformanceComplexType.subclass:
            return periodOfPerformanceComplexType.subclass(*args_, **kwargs_)
        else:
            return periodOfPerformanceComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodOfPerformanceActionDate(self): return self.periodOfPerformanceActionDate
    def set_periodOfPerformanceActionDate(self, periodOfPerformanceActionDate): self.periodOfPerformanceActionDate = periodOfPerformanceActionDate
    def get_periodOfPerformanceStartDate(self): return self.periodOfPerformanceStartDate
    def set_periodOfPerformanceStartDate(self, periodOfPerformanceStartDate): self.periodOfPerformanceStartDate = periodOfPerformanceStartDate
    def get_periodOfPerformanceCurrentEndDate(self): return self.periodOfPerformanceCurrentEndDate
    def set_periodOfPerformanceCurrentEndDate(self, periodOfPerformanceCurrentEndDate): self.periodOfPerformanceCurrentEndDate = periodOfPerformanceCurrentEndDate
    def get_periodOfPerformancePotentialEndDate(self): return self.periodOfPerformancePotentialEndDate
    def set_periodOfPerformancePotentialEndDate(self, periodOfPerformancePotentialEndDate): self.periodOfPerformancePotentialEndDate = periodOfPerformancePotentialEndDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.periodOfPerformanceActionDate is not None or
            self.periodOfPerformanceStartDate is not None or
            self.periodOfPerformanceCurrentEndDate is not None or
            self.periodOfPerformancePotentialEndDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='periodOfPerformanceComplexType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:award="http://www.xbrl.org/int/award/2006-10-25" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='periodOfPerformanceComplexType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='periodOfPerformanceComplexType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='periodOfPerformanceComplexType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='periodOfPerformanceComplexType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodOfPerformanceActionDate is not None:
            self.periodOfPerformanceActionDate.export(outfile, level, namespace_='award:', name_='periodOfPerformanceActionDate', pretty_print=pretty_print)
        if self.periodOfPerformanceStartDate is not None:
            self.periodOfPerformanceStartDate.export(outfile, level, namespace_='award:', name_='periodOfPerformanceStartDate', pretty_print=pretty_print)
        if self.periodOfPerformanceCurrentEndDate is not None:
            self.periodOfPerformanceCurrentEndDate.export(outfile, level, namespace_='award:', name_='periodOfPerformanceCurrentEndDate', pretty_print=pretty_print)
        if self.periodOfPerformancePotentialEndDate is not None:
            self.periodOfPerformancePotentialEndDate.export(outfile, level, namespace_='award:', name_='periodOfPerformancePotentialEndDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodOfPerformanceActionDate':
            obj_ = dateItemType.factory()
            obj_.build(child_)
            self.periodOfPerformanceActionDate = obj_
            obj_.original_tagname_ = 'periodOfPerformanceActionDate'
        elif nodeName_ == 'periodOfPerformanceStartDate':
            obj_ = dateItemType.factory()
            obj_.build(child_)
            self.periodOfPerformanceStartDate = obj_
            obj_.original_tagname_ = 'periodOfPerformanceStartDate'
        elif nodeName_ == 'periodOfPerformanceCurrentEndDate':
            obj_ = dateItemType.factory()
            obj_.build(child_)
            self.periodOfPerformanceCurrentEndDate = obj_
            obj_.original_tagname_ = 'periodOfPerformanceCurrentEndDate'
        elif nodeName_ == 'periodOfPerformancePotentialEndDate':
            obj_ = dateItemType.factory()
            obj_.build(child_)
            self.periodOfPerformancePotentialEndDate = obj_
            obj_.original_tagname_ = 'periodOfPerformancePotentialEndDate'
# end class periodOfPerformanceComplexType


class decimalItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if decimalItemType.subclass:
            return decimalItemType.subclass(*args_, **kwargs_)
        else:
            return decimalItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='decimalItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='decimalItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='decimalItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='decimalItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='decimalItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class decimalItemType


class floatItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if floatItemType.subclass:
            return floatItemType.subclass(*args_, **kwargs_)
        else:
            return floatItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='floatItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='floatItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='floatItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='floatItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='floatItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class floatItemType


class doubleItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if doubleItemType.subclass:
            return doubleItemType.subclass(*args_, **kwargs_)
        else:
            return doubleItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='doubleItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='doubleItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='doubleItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='doubleItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='doubleItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class doubleItemType


class monetaryItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if monetaryItemType.subclass:
            return monetaryItemType.subclass(*args_, **kwargs_)
        else:
            return monetaryItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='monetaryItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='monetaryItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='monetaryItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='monetaryItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='monetaryItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class monetaryItemType


class sharesItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if sharesItemType.subclass:
            return sharesItemType.subclass(*args_, **kwargs_)
        else:
            return sharesItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='sharesItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sharesItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='sharesItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='sharesItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='sharesItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sharesItemType


class pureItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if pureItemType.subclass:
            return pureItemType.subclass(*args_, **kwargs_)
        else:
            return pureItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='pureItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pureItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='pureItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='pureItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='pureItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pureItemType


class fractionItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, id=None, contextRef=None, numerator=None, denominator=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.numerator = numerator
        self.denominator = denominator
    def factory(*args_, **kwargs_):
        if fractionItemType.subclass:
            return fractionItemType.subclass(*args_, **kwargs_)
        else:
            return fractionItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numerator(self): return self.numerator
    def set_numerator(self, numerator): self.numerator = numerator
    def get_denominator(self): return self.denominator
    def set_denominator(self, denominator): self.denominator = denominator
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def hasContent_(self):
        if (
            self.numerator is not None or
            self.denominator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='fractionItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xbrli="http://www.xbrl.org/2003/instance" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fractionItemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='fractionItemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='fractionItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='fractionItemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numerator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumerator>%s</%snumerator>%s' % ('xbrli:', self.gds_format_string(quote_xml(self.numerator).encode(ExternalEncoding), input_name='numerator'), 'xbrli:', eol_))
        if self.denominator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdenominator>%s</%sdenominator>%s' % (namespace_, self.gds_format_float(self.denominator, input_name='denominator'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'numerator':
            numerator_ = child_.text
            numerator_ = self.gds_validate_string(numerator_, node, 'numerator')
            self.numerator = numerator_
        elif nodeName_ == 'denominator':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'denominator')
            self.denominator = fval_
# end class fractionItemType


class integerItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if integerItemType.subclass:
            return integerItemType.subclass(*args_, **kwargs_)
        else:
            return integerItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='integerItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='integerItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='integerItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='integerItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='integerItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class integerItemType


class nonPositiveIntegerItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if nonPositiveIntegerItemType.subclass:
            return nonPositiveIntegerItemType.subclass(*args_, **kwargs_)
        else:
            return nonPositiveIntegerItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='nonPositiveIntegerItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nonPositiveIntegerItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='nonPositiveIntegerItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='nonPositiveIntegerItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='nonPositiveIntegerItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nonPositiveIntegerItemType


class negativeIntegerItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if negativeIntegerItemType.subclass:
            return negativeIntegerItemType.subclass(*args_, **kwargs_)
        else:
            return negativeIntegerItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='negativeIntegerItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='negativeIntegerItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='negativeIntegerItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='negativeIntegerItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='negativeIntegerItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class negativeIntegerItemType


class longItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if longItemType.subclass:
            return longItemType.subclass(*args_, **kwargs_)
        else:
            return longItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='longItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='longItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='longItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='longItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='longItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class longItemType


class intItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if intItemType.subclass:
            return intItemType.subclass(*args_, **kwargs_)
        else:
            return intItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='intItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='intItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='intItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='intItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='intItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class intItemType


class shortItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if shortItemType.subclass:
            return shortItemType.subclass(*args_, **kwargs_)
        else:
            return shortItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='shortItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='shortItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='shortItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='shortItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='shortItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class shortItemType


class byteItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if byteItemType.subclass:
            return byteItemType.subclass(*args_, **kwargs_)
        else:
            return byteItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='byteItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='byteItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='byteItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='byteItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='byteItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class byteItemType


class nonNegativeIntegerItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if nonNegativeIntegerItemType.subclass:
            return nonNegativeIntegerItemType.subclass(*args_, **kwargs_)
        else:
            return nonNegativeIntegerItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='nonNegativeIntegerItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nonNegativeIntegerItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='nonNegativeIntegerItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='nonNegativeIntegerItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='nonNegativeIntegerItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nonNegativeIntegerItemType


class unsignedLongItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if unsignedLongItemType.subclass:
            return unsignedLongItemType.subclass(*args_, **kwargs_)
        else:
            return unsignedLongItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='unsignedLongItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedLongItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='unsignedLongItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='unsignedLongItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='unsignedLongItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class unsignedLongItemType


class unsignedIntItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if unsignedIntItemType.subclass:
            return unsignedIntItemType.subclass(*args_, **kwargs_)
        else:
            return unsignedIntItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='unsignedIntItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedIntItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='unsignedIntItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='unsignedIntItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='unsignedIntItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class unsignedIntItemType


class unsignedShortItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if unsignedShortItemType.subclass:
            return unsignedShortItemType.subclass(*args_, **kwargs_)
        else:
            return unsignedShortItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='unsignedShortItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedShortItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='unsignedShortItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='unsignedShortItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='unsignedShortItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class unsignedShortItemType


class unsignedByteItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if unsignedByteItemType.subclass:
            return unsignedByteItemType.subclass(*args_, **kwargs_)
        else:
            return unsignedByteItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='unsignedByteItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedByteItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='unsignedByteItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='unsignedByteItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='unsignedByteItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class unsignedByteItemType


class positiveIntegerItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitRef = _cast(None, unitRef)
        self.decimals = _cast(None, decimals)
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.precision = _cast(None, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if positiveIntegerItemType.subclass:
            return positiveIntegerItemType.subclass(*args_, **kwargs_)
        else:
            return positiveIntegerItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRef(self): return self.unitRef
    def set_unitRef(self, unitRef): self.unitRef = unitRef
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='positiveIntegerItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='positiveIntegerItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='positiveIntegerItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='positiveIntegerItemType'):
        if self.unitRef is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            outfile.write(' unitRef=%s' % (quote_attrib(self.unitRef), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals=%s' % (quote_attrib(self.decimals), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='positiveIntegerItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRef', node)
        if value is not None and 'unitRef' not in already_processed:
            already_processed.add('unitRef')
            self.unitRef = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            self.decimals = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class positiveIntegerItemType


class stringItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if stringItemType.subclass:
            return stringItemType.subclass(*args_, **kwargs_)
        else:
            return stringItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='stringItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stringItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='stringItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='stringItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='stringItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class stringItemType


class booleanItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if booleanItemType.subclass:
            return booleanItemType.subclass(*args_, **kwargs_)
        else:
            return booleanItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='booleanItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='booleanItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='booleanItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='booleanItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='booleanItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class booleanItemType


class hexBinaryItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if hexBinaryItemType.subclass:
            return hexBinaryItemType.subclass(*args_, **kwargs_)
        else:
            return hexBinaryItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='hexBinaryItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hexBinaryItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='hexBinaryItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='hexBinaryItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='hexBinaryItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class hexBinaryItemType


class base64BinaryItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if base64BinaryItemType.subclass:
            return base64BinaryItemType.subclass(*args_, **kwargs_)
        else:
            return base64BinaryItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='base64BinaryItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='base64BinaryItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='base64BinaryItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='base64BinaryItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='base64BinaryItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class base64BinaryItemType


class anyURIItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if anyURIItemType.subclass:
            return anyURIItemType.subclass(*args_, **kwargs_)
        else:
            return anyURIItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='anyURIItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='anyURIItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='anyURIItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='anyURIItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='anyURIItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class anyURIItemType


class QNameItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if QNameItemType.subclass:
            return QNameItemType.subclass(*args_, **kwargs_)
        else:
            return QNameItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='QNameItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QNameItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='QNameItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='QNameItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='QNameItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QNameItemType


class durationItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if durationItemType.subclass:
            return durationItemType.subclass(*args_, **kwargs_)
        else:
            return durationItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='durationItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='durationItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='durationItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='durationItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='durationItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class durationItemType


class dateTimeItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if dateTimeItemType.subclass:
            return dateTimeItemType.subclass(*args_, **kwargs_)
        else:
            return dateTimeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='dateTimeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dateTimeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='dateTimeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='dateTimeItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='dateTimeItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dateTimeItemType


class timeItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if timeItemType.subclass:
            return timeItemType.subclass(*args_, **kwargs_)
        else:
            return timeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='timeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='timeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='timeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='timeItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='timeItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class timeItemType


class dateItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if dateItemType.subclass:
            return dateItemType.subclass(*args_, **kwargs_)
        else:
            return dateItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='dateItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dateItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='dateItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='dateItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='dateItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dateItemType


class gYearMonthItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if gYearMonthItemType.subclass:
            return gYearMonthItemType.subclass(*args_, **kwargs_)
        else:
            return gYearMonthItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='gYearMonthItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gYearMonthItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='gYearMonthItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='gYearMonthItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='gYearMonthItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class gYearMonthItemType


class gYearItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if gYearItemType.subclass:
            return gYearItemType.subclass(*args_, **kwargs_)
        else:
            return gYearItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='gYearItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gYearItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='gYearItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='gYearItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='gYearItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class gYearItemType


class gMonthDayItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if gMonthDayItemType.subclass:
            return gMonthDayItemType.subclass(*args_, **kwargs_)
        else:
            return gMonthDayItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='gMonthDayItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gMonthDayItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='gMonthDayItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='gMonthDayItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='gMonthDayItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class gMonthDayItemType


class gDayItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if gDayItemType.subclass:
            return gDayItemType.subclass(*args_, **kwargs_)
        else:
            return gDayItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='gDayItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gDayItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='gDayItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='gDayItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='gDayItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class gDayItemType


class gMonthItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if gMonthItemType.subclass:
            return gMonthItemType.subclass(*args_, **kwargs_)
        else:
            return gMonthItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='gMonthItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gMonthItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='gMonthItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='gMonthItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='gMonthItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class gMonthItemType


class normalizedStringItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if normalizedStringItemType.subclass:
            return normalizedStringItemType.subclass(*args_, **kwargs_)
        else:
            return normalizedStringItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='normalizedStringItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='normalizedStringItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='normalizedStringItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='normalizedStringItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='normalizedStringItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class normalizedStringItemType


class tokenItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if tokenItemType.subclass:
            return tokenItemType.subclass(*args_, **kwargs_)
        else:
            return tokenItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='tokenItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tokenItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='tokenItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='tokenItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='tokenItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tokenItemType


class languageItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if languageItemType.subclass:
            return languageItemType.subclass(*args_, **kwargs_)
        else:
            return languageItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='languageItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='languageItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='languageItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='languageItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='languageItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class languageItemType


class NameItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if NameItemType.subclass:
            return NameItemType.subclass(*args_, **kwargs_)
        else:
            return NameItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='NameItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='NameItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='NameItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='NameItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameItemType


class NCNameItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.contextRef = _cast(None, contextRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if NCNameItemType.subclass:
            return NCNameItemType.subclass(*args_, **kwargs_)
        else:
            return NCNameItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_contextRef(self): return self.contextRef
    def set_contextRef(self, contextRef): self.contextRef = contextRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='NCNameItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NCNameItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='NCNameItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='NCNameItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.contextRef is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            outfile.write(' contextRef=%s' % (quote_attrib(self.contextRef), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='NCNameItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('contextRef', node)
        if value is not None and 'contextRef' not in already_processed:
            already_processed.add('contextRef')
            self.contextRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NCNameItemType


class segment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if segment.subclass:
            return segment.subclass(*args_, **kwargs_)
        else:
            return segment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='segment', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='segment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='segment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='segment'):
        pass
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='segment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'segment')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class segment


class contextEntityType(GeneratedsSuper):
    """The type for the entity element, used to describe the reporting
    entity. Note that the scheme attribute is required and cannot be
    empty."""
    subclass = None
    superclass = None
    def __init__(self, identifier=None, segment=None):
        self.original_tagname_ = None
        self.identifier = identifier
        self.segment = segment
    def factory(*args_, **kwargs_):
        if contextEntityType.subclass:
            return contextEntityType.subclass(*args_, **kwargs_)
        else:
            return contextEntityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_segment(self): return self.segment
    def set_segment(self, segment): self.segment = segment
    def hasContent_(self):
        if (
            self.identifier is not None or
            self.segment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='contextEntityType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xbrli="http://www.xbrl.org/2003/instance" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contextEntityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='contextEntityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='contextEntityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='contextEntityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_, name_='identifier', pretty_print=pretty_print)
        if self.segment is not None:
            self.segment.export(outfile, level, namespace_='xbrli:', name_='segment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'identifier':
            obj_ = identifierType.factory()
            obj_.build(child_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'segment':
            obj_ = segment.factory()
            obj_.build(child_)
            self.segment = obj_
            obj_.original_tagname_ = 'segment'
# end class contextEntityType


class contextPeriodType(GeneratedsSuper):
    """The type for the period element, used to describe the reporting date
    info."""
    subclass = None
    superclass = None
    def __init__(self, startDate=None, endDate=None, instant=None, forever=None):
        self.original_tagname_ = None
        self.startDate = startDate
        self.validate_dateUnion(self.startDate)
        self.endDate = endDate
        self.validate_dateUnion(self.endDate)
        self.instant = instant
        self.validate_dateUnion(self.instant)
        self.forever = forever
    def factory(*args_, **kwargs_):
        if contextPeriodType.subclass:
            return contextPeriodType.subclass(*args_, **kwargs_)
        else:
            return contextPeriodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startDate(self): return self.startDate
    def set_startDate(self, startDate): self.startDate = startDate
    def get_endDate(self): return self.endDate
    def set_endDate(self, endDate): self.endDate = endDate
    def get_instant(self): return self.instant
    def set_instant(self, instant): self.instant = instant
    def get_forever(self): return self.forever
    def set_forever(self, forever): self.forever = forever
    def validate_dateUnion(self, value):
        # Validate type dateUnion, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.startDate is not None or
            self.endDate is not None or
            self.instant is not None or
            self.forever is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='contextPeriodType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xbrli="http://www.xbrl.org/2003/instance" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contextPeriodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='contextPeriodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='contextPeriodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='contextPeriodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.startDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartDate>%s</%sstartDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.startDate).encode(ExternalEncoding), input_name='startDate'), namespace_, eol_))
        if self.endDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendDate>%s</%sendDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.endDate).encode(ExternalEncoding), input_name='endDate'), namespace_, eol_))
        if self.instant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstant>%s</%sinstant>%s' % (namespace_, self.gds_format_string(quote_xml(self.instant).encode(ExternalEncoding), input_name='instant'), namespace_, eol_))
        if self.forever is not None:
            self.forever.export(outfile, level, namespace_, name_='forever', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'startDate':
            startDate_ = child_.text
            startDate_ = self.gds_validate_string(startDate_, node, 'startDate')
            self.startDate = startDate_
            # validate type dateUnion
            self.validate_dateUnion(self.startDate)
        elif nodeName_ == 'endDate':
            endDate_ = child_.text
            endDate_ = self.gds_validate_string(endDate_, node, 'endDate')
            self.endDate = endDate_
            # validate type dateUnion
            self.validate_dateUnion(self.endDate)
        elif nodeName_ == 'instant':
            instant_ = child_.text
            instant_ = self.gds_validate_string(instant_, node, 'instant')
            self.instant = instant_
            # validate type dateUnion
            self.validate_dateUnion(self.instant)
        elif nodeName_ == 'forever':
            obj_ = foreverType.factory()
            obj_.build(child_)
            self.forever = obj_
            obj_.original_tagname_ = 'forever'
# end class contextPeriodType


class contextScenarioType(GeneratedsSuper):
    """Used for the scenario under which fact have been reported."""
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if contextScenarioType.subclass:
            return contextScenarioType.subclass(*args_, **kwargs_)
        else:
            return contextScenarioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='contextScenarioType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contextScenarioType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='contextScenarioType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='contextScenarioType'):
        pass
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='contextScenarioType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'contextScenarioType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class contextScenarioType


class context(GeneratedsSuper):
    """Used for an island of context to which facts can be related."""
    subclass = None
    superclass = None
    def __init__(self, id=None, entity=None, period=None, scenario=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.entity = entity
        self.period = period
        self.scenario = scenario
    def factory(*args_, **kwargs_):
        if context.subclass:
            return context.subclass(*args_, **kwargs_)
        else:
            return context(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_scenario(self): return self.scenario
    def set_scenario(self, scenario): self.scenario = scenario
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.entity is not None or
            self.period is not None or
            self.scenario is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='context', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xbrli="http://www.xbrl.org/2003/instance" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='context')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='context', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='context'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='context', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.entity is not None:
            self.entity.export(outfile, level, namespace_, name_='entity', pretty_print=pretty_print)
        if self.period is not None:
            self.period.export(outfile, level, namespace_, name_='period', pretty_print=pretty_print)
        if self.scenario is not None:
            self.scenario.export(outfile, level, namespace_, name_='scenario', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entity':
            obj_ = contextEntityType.factory()
            obj_.build(child_)
            self.entity = obj_
            obj_.original_tagname_ = 'entity'
        elif nodeName_ == 'period':
            obj_ = contextPeriodType.factory()
            obj_.build(child_)
            self.period = obj_
            obj_.original_tagname_ = 'period'
        elif nodeName_ == 'scenario':
            obj_ = contextScenarioType.factory()
            obj_.build(child_)
            self.scenario = obj_
            obj_.original_tagname_ = 'scenario'
# end class context


class measuresType(GeneratedsSuper):
    """A collection of sibling measure elements"""
    subclass = None
    superclass = None
    def __init__(self, measure=None):
        self.original_tagname_ = None
        if measure is None:
            self.measure = []
        else:
            self.measure = measure
    def factory(*args_, **kwargs_):
        if measuresType.subclass:
            return measuresType.subclass(*args_, **kwargs_)
        else:
            return measuresType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_measure(self): return self.measure
    def set_measure(self, measure): self.measure = measure
    def add_measure(self, value): self.measure.append(value)
    def insert_measure_at(self, index, value): self.measure.insert(index, value)
    def replace_measure_at(self, index, value): self.measure[index] = value
    def hasContent_(self):
        if (
            self.measure
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='measuresType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xbrli="http://www.xbrl.org/2003/instance" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='measuresType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='measuresType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='measuresType'):
        pass
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='measuresType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for measure_ in self.measure:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smeasure>%s</%smeasure>%s' % (namespace_, self.gds_format_string(quote_xml(measure_).encode(ExternalEncoding), input_name='measure'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'measure':
            measure_ = child_.text
            measure_ = self.gds_validate_string(measure_, node, 'measure')
            self.measure.append(measure_)
# end class measuresType


class divide(GeneratedsSuper):
    """Element used to represent division in units"""
    subclass = None
    superclass = None
    def __init__(self, unitNumerator=None, unitDenominator=None):
        self.original_tagname_ = None
        self.unitNumerator = unitNumerator
        self.unitDenominator = unitDenominator
    def factory(*args_, **kwargs_):
        if divide.subclass:
            return divide.subclass(*args_, **kwargs_)
        else:
            return divide(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitNumerator(self): return self.unitNumerator
    def set_unitNumerator(self, unitNumerator): self.unitNumerator = unitNumerator
    def get_unitDenominator(self): return self.unitDenominator
    def set_unitDenominator(self, unitDenominator): self.unitDenominator = unitDenominator
    def hasContent_(self):
        if (
            self.unitNumerator is not None or
            self.unitDenominator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='divide', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xbrli="http://www.xbrl.org/2003/instance" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='divide')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='divide', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='divide'):
        pass
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='divide', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unitNumerator is not None:
            self.unitNumerator.export(outfile, level, namespace_, name_='unitNumerator', pretty_print=pretty_print)
        if self.unitDenominator is not None:
            self.unitDenominator.export(outfile, level, namespace_, name_='unitDenominator', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unitNumerator':
            obj_ = measuresType.factory()
            obj_.build(child_)
            self.unitNumerator = obj_
            obj_.original_tagname_ = 'unitNumerator'
        elif nodeName_ == 'unitDenominator':
            obj_ = measuresType.factory()
            obj_.build(child_)
            self.unitDenominator = obj_
            obj_.original_tagname_ = 'unitDenominator'
# end class divide


class unit(GeneratedsSuper):
    """Element used to represent units information about numeric items"""
    subclass = None
    superclass = None
    def __init__(self, id=None, measure=None, divide=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if measure is None:
            self.measure = []
        else:
            self.measure = measure
        self.divide = divide
    def factory(*args_, **kwargs_):
        if unit.subclass:
            return unit.subclass(*args_, **kwargs_)
        else:
            return unit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_measure(self): return self.measure
    def set_measure(self, measure): self.measure = measure
    def add_measure(self, value): self.measure.append(value)
    def insert_measure_at(self, index, value): self.measure.insert(index, value)
    def replace_measure_at(self, index, value): self.measure[index] = value
    def get_divide(self): return self.divide
    def set_divide(self, divide): self.divide = divide
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.measure or
            self.divide is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='unit', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xbrli="http://www.xbrl.org/2003/instance" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='unit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='unit'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='unit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for measure_ in self.measure:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smeasure>%s</%smeasure>%s' % (namespace_, self.gds_format_string(quote_xml(measure_).encode(ExternalEncoding), input_name='measure'), namespace_, eol_))
        if self.divide is not None:
            self.divide.export(outfile, level, namespace_='xbrli:', name_='divide', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'measure':
            measure_ = child_.text
            measure_ = self.gds_validate_string(measure_, node, 'measure')
            self.measure.append(measure_)
        elif nodeName_ == 'divide':
            obj_ = divide.factory()
            obj_.build(child_)
            self.divide = obj_
            obj_.original_tagname_ = 'divide'
# end class unit


class xbrl(GeneratedsSuper):
    """XBRL instance root element."""
    subclass = None
    superclass = None
    def __init__(self, id=None, schemaRef=None, linkbaseRef=None, roleRef=None, arcroleRef=None, item=None, tuple=None, context=None, unit=None, footnoteLink=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if schemaRef is None:
            self.schemaRef = []
        else:
            self.schemaRef = schemaRef
        if linkbaseRef is None:
            self.linkbaseRef = []
        else:
            self.linkbaseRef = linkbaseRef
        if roleRef is None:
            self.roleRef = []
        else:
            self.roleRef = roleRef
        if arcroleRef is None:
            self.arcroleRef = []
        else:
            self.arcroleRef = arcroleRef
        if item is None:
            self.item = []
        else:
            self.item = item
        if tuple is None:
            self.tuple = []
        else:
            self.tuple = tuple
        if context is None:
            self.context = []
        else:
            self.context = context
        if unit is None:
            self.unit = []
        else:
            self.unit = unit
        if footnoteLink is None:
            self.footnoteLink = []
        else:
            self.footnoteLink = footnoteLink
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if xbrl.subclass:
            return xbrl.subclass(*args_, **kwargs_)
        else:
            return xbrl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_schemaRef(self): return self.schemaRef
    def set_schemaRef(self, schemaRef): self.schemaRef = schemaRef
    def add_schemaRef(self, value): self.schemaRef.append(value)
    def insert_schemaRef_at(self, index, value): self.schemaRef.insert(index, value)
    def replace_schemaRef_at(self, index, value): self.schemaRef[index] = value
    def get_linkbaseRef(self): return self.linkbaseRef
    def set_linkbaseRef(self, linkbaseRef): self.linkbaseRef = linkbaseRef
    def add_linkbaseRef(self, value): self.linkbaseRef.append(value)
    def insert_linkbaseRef_at(self, index, value): self.linkbaseRef.insert(index, value)
    def replace_linkbaseRef_at(self, index, value): self.linkbaseRef[index] = value
    def get_roleRef(self): return self.roleRef
    def set_roleRef(self, roleRef): self.roleRef = roleRef
    def add_roleRef(self, value): self.roleRef.append(value)
    def insert_roleRef_at(self, index, value): self.roleRef.insert(index, value)
    def replace_roleRef_at(self, index, value): self.roleRef[index] = value
    def get_arcroleRef(self): return self.arcroleRef
    def set_arcroleRef(self, arcroleRef): self.arcroleRef = arcroleRef
    def add_arcroleRef(self, value): self.arcroleRef.append(value)
    def insert_arcroleRef_at(self, index, value): self.arcroleRef.insert(index, value)
    def replace_arcroleRef_at(self, index, value): self.arcroleRef[index] = value
    def get_item(self): return self.item
    def set_item(self, item): self.item = item
    def add_item(self, value): self.item.append(value)
    def insert_item_at(self, index, value): self.item.insert(index, value)
    def replace_item_at(self, index, value): self.item[index] = value
    def get_tuple(self): return self.tuple
    def set_tuple(self, tuple): self.tuple = tuple
    def add_tuple(self, value): self.tuple.append(value)
    def insert_tuple_at(self, index, value): self.tuple.insert(index, value)
    def replace_tuple_at(self, index, value): self.tuple[index] = value
    def get_context(self): return self.context
    def set_context(self, context): self.context = context
    def add_context(self, value): self.context.append(value)
    def insert_context_at(self, index, value): self.context.insert(index, value)
    def replace_context_at(self, index, value): self.context[index] = value
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def add_unit(self, value): self.unit.append(value)
    def insert_unit_at(self, index, value): self.unit.insert(index, value)
    def replace_unit_at(self, index, value): self.unit[index] = value
    def get_footnoteLink(self): return self.footnoteLink
    def set_footnoteLink(self, footnoteLink): self.footnoteLink = footnoteLink
    def add_footnoteLink(self, value): self.footnoteLink.append(value)
    def insert_footnoteLink_at(self, index, value): self.footnoteLink.insert(index, value)
    def replace_footnoteLink_at(self, index, value): self.footnoteLink[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.schemaRef or
            self.linkbaseRef or
            self.roleRef or
            self.arcroleRef or
            self.item or
            self.tuple or
            self.context or
            self.unit or
            self.footnoteLink
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='xbrl', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xbrli="http://www.xbrl.org/2003/instance" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xbrl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='xbrl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='xbrl'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='xbrl', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for schemaRef_ in self.schemaRef:
            schemaRef_.export(outfile, level, namespace_='link:', name_='schemaRef', pretty_print=pretty_print)
        for linkbaseRef_ in self.linkbaseRef:
            linkbaseRef_.export(outfile, level, namespace_='link:', name_='linkbaseRef', pretty_print=pretty_print)
        for roleRef_ in self.roleRef:
            roleRef_.export(outfile, level, namespace_='link:', name_='roleRef', pretty_print=pretty_print)
        for arcroleRef_ in self.arcroleRef:
            arcroleRef_.export(outfile, level, namespace_='link:', name_='arcroleRef', pretty_print=pretty_print)
        for item_ in self.item:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sitem>%s</%sitem>%s' % (namespace_, self.gds_format_string(quote_xml(item_).encode(ExternalEncoding), input_name='item'), namespace_, eol_))
        for tuple_ in self.tuple:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stuple>%s</%stuple>%s' % (namespace_, self.gds_format_string(quote_xml(tuple_).encode(ExternalEncoding), input_name='tuple'), namespace_, eol_))
        for context_ in self.context:
            context_.export(outfile, level, namespace_='xbrli:', name_='context', pretty_print=pretty_print)
        for unit_ in self.unit:
            unit_.export(outfile, level, namespace_='xbrli:', name_='unit', pretty_print=pretty_print)
        for footnoteLink_ in self.footnoteLink:
            footnoteLink_.export(outfile, level, namespace_='link:', name_='footnoteLink', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'schemaRef':
            class_obj_ = self.get_class_obj_(child_, simpleType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.schemaRef.append(obj_)
            obj_.original_tagname_ = 'schemaRef'
        elif nodeName_ == 'linkbaseRef':
            obj_ = linkbaseRef.factory()
            obj_.build(child_)
            self.linkbaseRef.append(obj_)
            obj_.original_tagname_ = 'linkbaseRef'
        elif nodeName_ == 'roleRef':
            obj_ = roleRef.factory()
            obj_.build(child_)
            self.roleRef.append(obj_)
            obj_.original_tagname_ = 'roleRef'
        elif nodeName_ == 'arcroleRef':
            obj_ = arcroleRef.factory()
            obj_.build(child_)
            self.arcroleRef.append(obj_)
            obj_.original_tagname_ = 'arcroleRef'
        elif nodeName_ == 'item':
            item_ = child_.text
            item_ = self.gds_validate_string(item_, node, 'item')
            self.item.append(item_)
        elif nodeName_ == 'catalogOfFederalDomesticAssistanceTitle':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'catalogOfFederalDomesticAssistanceTitle'
        elif nodeName_ == 'catalogOfFederalDomesticAssistanceNumber':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'catalogOfFederalDomesticAssistanceNumber'
        elif nodeName_ == 'totalFundingAmount':
            obj_ = amountItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'totalFundingAmount'
        elif nodeName_ == 'nonFederalFundingAmount':
            obj_ = amountItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'nonFederalFundingAmount'
        elif nodeName_ == 'allocationTransferAgencyIdentifier':
            obj_ = integerItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'allocationTransferAgencyIdentifier'
        elif nodeName_ == 'mainAccountNumber':
            obj_ = integerItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'mainAccountNumber'
        elif nodeName_ == 'subAccountSymbol':
            obj_ = integerItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'subAccountSymbol'
        elif nodeName_ == 'beginningPeriodOfAvailability':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'beginningPeriodOfAvailability'
        elif nodeName_ == 'endingPeriodOfAvailability':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'endingPeriodOfAvailability'
        elif nodeName_ == 'availabilityTypeCode':
            obj_ = availableTypeCodeItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'availabilityTypeCode'
        elif nodeName_ == 'streetAddressLine':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'streetAddressLine'
        elif nodeName_ == 'city':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'city'
        elif nodeName_ == 'county':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'county'
        elif nodeName_ == 'state':
            obj_ = stateItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'state'
        elif nodeName_ == 'zipCodePlus4':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'zipCodePlus4'
        elif nodeName_ == 'postalCode':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'postalCode'
        elif nodeName_ == 'countryName':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'countryName'
        elif nodeName_ == 'countryCode':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'countryCode'
        elif nodeName_ == 'congressionalDistrict':
            obj_ = congressionalDistrictItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'congressionalDistrict'
        elif nodeName_ == 'agencyIdentifier':
            obj_ = integerItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'agencyIdentifier'
        elif nodeName_ == 'agencyName':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'agencyName'
        elif nodeName_ == 'officeIdentifier':
            obj_ = integerItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'officeIdentifier'
        elif nodeName_ == 'officeName':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'officeName'
        elif nodeName_ == 'awardID':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'awardID'
        elif nodeName_ == 'awardDescription':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'awardDescription'
        elif nodeName_ == 'parentAwardID':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'parentAwardID'
        elif nodeName_ == 'awardeeLegalBusinessName':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'awardeeLegalBusinessName'
        elif nodeName_ == 'businessType':
            obj_ = businessTypeItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'businessType'
        elif nodeName_ == 'recordType':
            obj_ = recordTypeItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'recordType'
        elif nodeName_ == 'typeOfAction':
            obj_ = typeOfActionItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'typeOfAction'
        elif nodeName_ == 'typeOfTransactionCode':
            obj_ = typeOfTransactionCodeItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'typeOfTransactionCode'
        elif nodeName_ == 'modificationAmendmentNumber':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'modificationAmendmentNumber'
        elif nodeName_ == 'ultimateParentUniqueIdentifier':
            obj_ = integerItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'ultimateParentUniqueIdentifier'
        elif nodeName_ == 'awardeeUniqueIdentifier':
            obj_ = integerItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'awardeeUniqueIdentifier'
        elif nodeName_ == 'awardeeUniqueIdentifierSupplemental':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'awardeeUniqueIdentifierSupplemental'
        elif nodeName_ == 'ultimateParentLegalBusinessName':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'ultimateParentLegalBusinessName'
        elif nodeName_ == 'periodOfPerformanceActionDate':
            obj_ = dateItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'periodOfPerformanceActionDate'
        elif nodeName_ == 'periodOfPerformanceStartDate':
            obj_ = dateItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'periodOfPerformanceStartDate'
        elif nodeName_ == 'periodOfPerformanceCurrentEndDate':
            obj_ = dateItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'periodOfPerformanceCurrentEndDate'
        elif nodeName_ == 'periodOfPerformancePotentialEndDate':
            obj_ = dateItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'periodOfPerformancePotentialEndDate'
        elif nodeName_ == 'highlyCompensatedOfficerFirstName':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'highlyCompensatedOfficerFirstName'
        elif nodeName_ == 'highlyCompensatedOfficerMiddleInitial':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'highlyCompensatedOfficerMiddleInitial'
        elif nodeName_ == 'highlyCompensatedOfficerLastName':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'highlyCompensatedOfficerLastName'
        elif nodeName_ == 'highlyCompensatedOfficerCompensation':
            obj_ = amountItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'highlyCompensatedOfficerCompensation'
        elif nodeName_ == 'federalFundingAmount':
            obj_ = amountItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'federalFundingAmount'
        elif nodeName_ == 'tuple':
            tuple_ = child_.text
            tuple_ = self.gds_validate_string(tuple_, node, 'tuple')
            self.tuple.append(tuple_)
        elif nodeName_ == 'award':
            obj_ = awardComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'award'
        elif nodeName_ == 'awardeeInformation':
            obj_ = awardeeInformationComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'awardeeInformation'
        elif nodeName_ == 'catalogOfFederalDomesticAssistanceProgram':
            obj_ = catalogOfFederalDomesticAssistanceProgramComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'catalogOfFederalDomesticAssistanceProgram'
        elif nodeName_ == 'awardAmounts':
            obj_ = awardAmountsComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'awardAmounts'
        elif nodeName_ == 'periodOfPerformance':
            obj_ = periodOfPerformanceComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'periodOfPerformance'
        elif nodeName_ == 'treasuryAccountSymbol':
            obj_ = TreasuryAccountSymbolComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'treasuryAccountSymbol'
        elif nodeName_ == 'address':
            obj_ = addressComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'streetAddress':
            obj_ = streetAddressComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'streetAddress'
        elif nodeName_ == 'agency':
            obj_ = agencyComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'agency'
        elif nodeName_ == 'agencyOffice':
            obj_ = agencyOfficeComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'agencyOffice'
        elif nodeName_ == 'awardeeAddress':
            obj_ = addressComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'awardeeAddress'
        elif nodeName_ == 'primaryPlaceOfPerformance':
            obj_ = addressComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'primaryPlaceOfPerformance'
        elif nodeName_ == 'awardingAgency':
            obj_ = agencyComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'awardingAgency'
        elif nodeName_ == 'fundingAgency':
            obj_ = agencyComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'fundingAgency'
        elif nodeName_ == 'awardingSubTierAgency':
            obj_ = agencyComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'awardingSubTierAgency'
        elif nodeName_ == 'fundingSubTierAgency':
            obj_ = agencyComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'fundingSubTierAgency'
        elif nodeName_ == 'highlyCompensatedOfficer':
            obj_ = highlyCompensatedOfficerComplexType.factory()
            obj_.build(child_)
            self.tuple.append(obj_)
            obj_.original_tagname_ = 'highlyCompensatedOfficer'
        elif nodeName_ == 'context':
            obj_ = context.factory()
            obj_.build(child_)
            self.context.append(obj_)
            obj_.original_tagname_ = 'context'
        elif nodeName_ == 'unit':
            obj_ = unit.factory()
            obj_.build(child_)
            self.unit.append(obj_)
            obj_.original_tagname_ = 'unit'
        elif nodeName_ == 'footnoteLink':
            obj_ = footnoteLink.factory()
            obj_.build(child_)
            self.footnoteLink.append(obj_)
            obj_.original_tagname_ = 'footnoteLink'
# end class xbrl


class presentationLink(GeneratedsSuper):
    """presentation extended link element definition."""
    subclass = None
    superclass = None
    def __init__(self, title=None, documentation=None, loc=None, presentationArc=None):
        self.original_tagname_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        if documentation is None:
            self.documentation = []
        else:
            self.documentation = documentation
        if loc is None:
            self.loc = []
        else:
            self.loc = loc
        if presentationArc is None:
            self.presentationArc = []
        else:
            self.presentationArc = presentationArc
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if presentationLink.subclass:
            return presentationLink.subclass(*args_, **kwargs_)
        else:
            return presentationLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title_at(self, index, value): self.title.insert(index, value)
    def replace_title_at(self, index, value): self.title[index] = value
    def get_documentation(self): return self.documentation
    def set_documentation(self, documentation): self.documentation = documentation
    def add_documentation(self, value): self.documentation.append(value)
    def insert_documentation_at(self, index, value): self.documentation.insert(index, value)
    def replace_documentation_at(self, index, value): self.documentation[index] = value
    def get_loc(self): return self.loc
    def set_loc(self, loc): self.loc = loc
    def add_loc(self, value): self.loc.append(value)
    def insert_loc_at(self, index, value): self.loc.insert(index, value)
    def replace_loc_at(self, index, value): self.loc[index] = value
    def get_presentationArc(self): return self.presentationArc
    def set_presentationArc(self, presentationArc): self.presentationArc = presentationArc
    def add_presentationArc(self, value): self.presentationArc.append(value)
    def insert_presentationArc_at(self, index, value): self.presentationArc.insert(index, value)
    def replace_presentationArc_at(self, index, value): self.presentationArc[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.title or
            self.documentation or
            self.loc or
            self.presentationArc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='presentationLink', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xl="http://www.xbrl.org/2003/XLink" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='presentationLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='presentationLink', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='presentationLink'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='presentationLink', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for documentation_ in self.documentation:
            documentation_.export(outfile, level, namespace_, name_='documentation', pretty_print=pretty_print)
        for loc_ in self.loc:
            loc_.export(outfile, level, namespace_='link:', name_='loc', pretty_print=pretty_print)
        for presentationArc_ in self.presentationArc:
            presentationArc_.export(outfile, level, namespace_='link:', name_='presentationArc', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'documentation':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <documentation> element')
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'documentation':
            obj_ = documentationType.factory()
            obj_.build(child_)
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'loc':
            obj_ = locatorType.factory()
            obj_.build(child_)
            self.loc.append(obj_)
            obj_.original_tagname_ = 'loc'
        elif nodeName_ == 'presentationArc':
            obj_ = presentationArc.factory()
            obj_.build(child_)
            self.presentationArc.append(obj_)
            obj_.original_tagname_ = 'presentationArc'
# end class presentationLink


class definitionLink(GeneratedsSuper):
    """definition extended link element definition"""
    subclass = None
    superclass = None
    def __init__(self, title=None, documentation=None, loc=None, definitionArc=None):
        self.original_tagname_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        if documentation is None:
            self.documentation = []
        else:
            self.documentation = documentation
        if loc is None:
            self.loc = []
        else:
            self.loc = loc
        if definitionArc is None:
            self.definitionArc = []
        else:
            self.definitionArc = definitionArc
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if definitionLink.subclass:
            return definitionLink.subclass(*args_, **kwargs_)
        else:
            return definitionLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title_at(self, index, value): self.title.insert(index, value)
    def replace_title_at(self, index, value): self.title[index] = value
    def get_documentation(self): return self.documentation
    def set_documentation(self, documentation): self.documentation = documentation
    def add_documentation(self, value): self.documentation.append(value)
    def insert_documentation_at(self, index, value): self.documentation.insert(index, value)
    def replace_documentation_at(self, index, value): self.documentation[index] = value
    def get_loc(self): return self.loc
    def set_loc(self, loc): self.loc = loc
    def add_loc(self, value): self.loc.append(value)
    def insert_loc_at(self, index, value): self.loc.insert(index, value)
    def replace_loc_at(self, index, value): self.loc[index] = value
    def get_definitionArc(self): return self.definitionArc
    def set_definitionArc(self, definitionArc): self.definitionArc = definitionArc
    def add_definitionArc(self, value): self.definitionArc.append(value)
    def insert_definitionArc_at(self, index, value): self.definitionArc.insert(index, value)
    def replace_definitionArc_at(self, index, value): self.definitionArc[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.title or
            self.documentation or
            self.loc or
            self.definitionArc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='definitionLink', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xl="http://www.xbrl.org/2003/XLink" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='definitionLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='definitionLink', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='definitionLink'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='definitionLink', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for documentation_ in self.documentation:
            documentation_.export(outfile, level, namespace_, name_='documentation', pretty_print=pretty_print)
        for loc_ in self.loc:
            loc_.export(outfile, level, namespace_='link:', name_='loc', pretty_print=pretty_print)
        for definitionArc_ in self.definitionArc:
            definitionArc_.export(outfile, level, namespace_='link:', name_='definitionArc', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'documentation':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <documentation> element')
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'documentation':
            obj_ = documentationType.factory()
            obj_.build(child_)
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'loc':
            obj_ = locatorType.factory()
            obj_.build(child_)
            self.loc.append(obj_)
            obj_.original_tagname_ = 'loc'
        elif nodeName_ == 'definitionArc':
            class_obj_ = self.get_class_obj_(child_, arcType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.definitionArc.append(obj_)
            obj_.original_tagname_ = 'definitionArc'
# end class definitionLink


class calculationLink(GeneratedsSuper):
    """calculation extended link element definition"""
    subclass = None
    superclass = None
    def __init__(self, title=None, documentation=None, loc=None, calculationArc=None):
        self.original_tagname_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        if documentation is None:
            self.documentation = []
        else:
            self.documentation = documentation
        if loc is None:
            self.loc = []
        else:
            self.loc = loc
        if calculationArc is None:
            self.calculationArc = []
        else:
            self.calculationArc = calculationArc
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if calculationLink.subclass:
            return calculationLink.subclass(*args_, **kwargs_)
        else:
            return calculationLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title_at(self, index, value): self.title.insert(index, value)
    def replace_title_at(self, index, value): self.title[index] = value
    def get_documentation(self): return self.documentation
    def set_documentation(self, documentation): self.documentation = documentation
    def add_documentation(self, value): self.documentation.append(value)
    def insert_documentation_at(self, index, value): self.documentation.insert(index, value)
    def replace_documentation_at(self, index, value): self.documentation[index] = value
    def get_loc(self): return self.loc
    def set_loc(self, loc): self.loc = loc
    def add_loc(self, value): self.loc.append(value)
    def insert_loc_at(self, index, value): self.loc.insert(index, value)
    def replace_loc_at(self, index, value): self.loc[index] = value
    def get_calculationArc(self): return self.calculationArc
    def set_calculationArc(self, calculationArc): self.calculationArc = calculationArc
    def add_calculationArc(self, value): self.calculationArc.append(value)
    def insert_calculationArc_at(self, index, value): self.calculationArc.insert(index, value)
    def replace_calculationArc_at(self, index, value): self.calculationArc[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.title or
            self.documentation or
            self.loc or
            self.calculationArc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='calculationLink', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xl="http://www.xbrl.org/2003/XLink" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='calculationLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='calculationLink', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='calculationLink'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='calculationLink', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for documentation_ in self.documentation:
            documentation_.export(outfile, level, namespace_, name_='documentation', pretty_print=pretty_print)
        for loc_ in self.loc:
            loc_.export(outfile, level, namespace_='link:', name_='loc', pretty_print=pretty_print)
        for calculationArc_ in self.calculationArc:
            calculationArc_.export(outfile, level, namespace_='link:', name_='calculationArc', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'documentation':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <documentation> element')
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'documentation':
            obj_ = documentationType.factory()
            obj_.build(child_)
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'loc':
            obj_ = locatorType.factory()
            obj_.build(child_)
            self.loc.append(obj_)
            obj_.original_tagname_ = 'loc'
        elif nodeName_ == 'calculationArc':
            obj_ = calculationArc.factory()
            obj_.build(child_)
            self.calculationArc.append(obj_)
            obj_.original_tagname_ = 'calculationArc'
# end class calculationLink


class labelLink(GeneratedsSuper):
    """label extended link element definition"""
    subclass = None
    superclass = None
    def __init__(self, title=None, documentation=None, loc=None, labelArc=None, label=None):
        self.original_tagname_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        if documentation is None:
            self.documentation = []
        else:
            self.documentation = documentation
        if loc is None:
            self.loc = []
        else:
            self.loc = loc
        if labelArc is None:
            self.labelArc = []
        else:
            self.labelArc = labelArc
        if label is None:
            self.label = []
        else:
            self.label = label
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if labelLink.subclass:
            return labelLink.subclass(*args_, **kwargs_)
        else:
            return labelLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title_at(self, index, value): self.title.insert(index, value)
    def replace_title_at(self, index, value): self.title[index] = value
    def get_documentation(self): return self.documentation
    def set_documentation(self, documentation): self.documentation = documentation
    def add_documentation(self, value): self.documentation.append(value)
    def insert_documentation_at(self, index, value): self.documentation.insert(index, value)
    def replace_documentation_at(self, index, value): self.documentation[index] = value
    def get_loc(self): return self.loc
    def set_loc(self, loc): self.loc = loc
    def add_loc(self, value): self.loc.append(value)
    def insert_loc_at(self, index, value): self.loc.insert(index, value)
    def replace_loc_at(self, index, value): self.loc[index] = value
    def get_labelArc(self): return self.labelArc
    def set_labelArc(self, labelArc): self.labelArc = labelArc
    def add_labelArc(self, value): self.labelArc.append(value)
    def insert_labelArc_at(self, index, value): self.labelArc.insert(index, value)
    def replace_labelArc_at(self, index, value): self.labelArc[index] = value
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def add_label(self, value): self.label.append(value)
    def insert_label_at(self, index, value): self.label.insert(index, value)
    def replace_label_at(self, index, value): self.label[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.title or
            self.documentation or
            self.loc or
            self.labelArc or
            self.label
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='labelLink', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xl="http://www.xbrl.org/2003/XLink" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='labelLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='labelLink', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='labelLink'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='labelLink', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for documentation_ in self.documentation:
            documentation_.export(outfile, level, namespace_, name_='documentation', pretty_print=pretty_print)
        for loc_ in self.loc:
            loc_.export(outfile, level, namespace_='link:', name_='loc', pretty_print=pretty_print)
        for labelArc_ in self.labelArc:
            labelArc_.export(outfile, level, namespace_='link:', name_='labelArc', pretty_print=pretty_print)
        for label_ in self.label:
            label_.export(outfile, level, namespace_='link:', name_='label', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'documentation':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <documentation> element')
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'documentation':
            obj_ = documentationType.factory()
            obj_.build(child_)
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'loc':
            obj_ = locatorType.factory()
            obj_.build(child_)
            self.loc.append(obj_)
            obj_.original_tagname_ = 'loc'
        elif nodeName_ == 'labelArc':
            class_obj_ = self.get_class_obj_(child_, arcType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.labelArc.append(obj_)
            obj_.original_tagname_ = 'labelArc'
        elif nodeName_ == 'label':
            obj_ = label.factory()
            obj_.build(child_)
            self.label.append(obj_)
            obj_.original_tagname_ = 'label'
# end class labelLink


class referenceLink(GeneratedsSuper):
    """reference extended link element definition"""
    subclass = None
    superclass = None
    def __init__(self, title=None, documentation=None, loc=None, referenceArc=None, reference=None):
        self.original_tagname_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        if documentation is None:
            self.documentation = []
        else:
            self.documentation = documentation
        if loc is None:
            self.loc = []
        else:
            self.loc = loc
        if referenceArc is None:
            self.referenceArc = []
        else:
            self.referenceArc = referenceArc
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if referenceLink.subclass:
            return referenceLink.subclass(*args_, **kwargs_)
        else:
            return referenceLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title_at(self, index, value): self.title.insert(index, value)
    def replace_title_at(self, index, value): self.title[index] = value
    def get_documentation(self): return self.documentation
    def set_documentation(self, documentation): self.documentation = documentation
    def add_documentation(self, value): self.documentation.append(value)
    def insert_documentation_at(self, index, value): self.documentation.insert(index, value)
    def replace_documentation_at(self, index, value): self.documentation[index] = value
    def get_loc(self): return self.loc
    def set_loc(self, loc): self.loc = loc
    def add_loc(self, value): self.loc.append(value)
    def insert_loc_at(self, index, value): self.loc.insert(index, value)
    def replace_loc_at(self, index, value): self.loc[index] = value
    def get_referenceArc(self): return self.referenceArc
    def set_referenceArc(self, referenceArc): self.referenceArc = referenceArc
    def add_referenceArc(self, value): self.referenceArc.append(value)
    def insert_referenceArc_at(self, index, value): self.referenceArc.insert(index, value)
    def replace_referenceArc_at(self, index, value): self.referenceArc[index] = value
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def add_reference(self, value): self.reference.append(value)
    def insert_reference_at(self, index, value): self.reference.insert(index, value)
    def replace_reference_at(self, index, value): self.reference[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.title or
            self.documentation or
            self.loc or
            self.referenceArc or
            self.reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='referenceLink', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xl="http://www.xbrl.org/2003/XLink" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='referenceLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='referenceLink', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='referenceLink'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='referenceLink', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for documentation_ in self.documentation:
            documentation_.export(outfile, level, namespace_, name_='documentation', pretty_print=pretty_print)
        for loc_ in self.loc:
            loc_.export(outfile, level, namespace_='link:', name_='loc', pretty_print=pretty_print)
        for referenceArc_ in self.referenceArc:
            referenceArc_.export(outfile, level, namespace_='link:', name_='referenceArc', pretty_print=pretty_print)
        for reference_ in self.reference:
            reference_.export(outfile, level, namespace_='link:', name_='reference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'documentation':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <documentation> element')
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'documentation':
            obj_ = documentationType.factory()
            obj_.build(child_)
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'loc':
            obj_ = locatorType.factory()
            obj_.build(child_)
            self.loc.append(obj_)
            obj_.original_tagname_ = 'loc'
        elif nodeName_ == 'referenceArc':
            class_obj_ = self.get_class_obj_(child_, arcType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.referenceArc.append(obj_)
            obj_.original_tagname_ = 'referenceArc'
        elif nodeName_ == 'reference':
            obj_ = reference.factory()
            obj_.build(child_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
# end class referenceLink


class footnoteLink(GeneratedsSuper):
    """footnote extended link element definition"""
    subclass = None
    superclass = None
    def __init__(self, title=None, documentation=None, loc=None, footnoteArc=None, footnote=None):
        self.original_tagname_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        if documentation is None:
            self.documentation = []
        else:
            self.documentation = documentation
        if loc is None:
            self.loc = []
        else:
            self.loc = loc
        if footnoteArc is None:
            self.footnoteArc = []
        else:
            self.footnoteArc = footnoteArc
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if footnoteLink.subclass:
            return footnoteLink.subclass(*args_, **kwargs_)
        else:
            return footnoteLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title_at(self, index, value): self.title.insert(index, value)
    def replace_title_at(self, index, value): self.title[index] = value
    def get_documentation(self): return self.documentation
    def set_documentation(self, documentation): self.documentation = documentation
    def add_documentation(self, value): self.documentation.append(value)
    def insert_documentation_at(self, index, value): self.documentation.insert(index, value)
    def replace_documentation_at(self, index, value): self.documentation[index] = value
    def get_loc(self): return self.loc
    def set_loc(self, loc): self.loc = loc
    def add_loc(self, value): self.loc.append(value)
    def insert_loc_at(self, index, value): self.loc.insert(index, value)
    def replace_loc_at(self, index, value): self.loc[index] = value
    def get_footnoteArc(self): return self.footnoteArc
    def set_footnoteArc(self, footnoteArc): self.footnoteArc = footnoteArc
    def add_footnoteArc(self, value): self.footnoteArc.append(value)
    def insert_footnoteArc_at(self, index, value): self.footnoteArc.insert(index, value)
    def replace_footnoteArc_at(self, index, value): self.footnoteArc[index] = value
    def get_footnote(self): return self.footnote
    def set_footnote(self, footnote): self.footnote = footnote
    def add_footnote(self, value): self.footnote.append(value)
    def insert_footnote_at(self, index, value): self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value): self.footnote[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.title or
            self.documentation or
            self.loc or
            self.footnoteArc or
            self.footnote
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='footnoteLink', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xl="http://www.xbrl.org/2003/XLink" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='footnoteLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='footnoteLink', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='footnoteLink'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='footnoteLink', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for documentation_ in self.documentation:
            documentation_.export(outfile, level, namespace_, name_='documentation', pretty_print=pretty_print)
        for loc_ in self.loc:
            loc_.export(outfile, level, namespace_='link:', name_='loc', pretty_print=pretty_print)
        for footnoteArc_ in self.footnoteArc:
            footnoteArc_.export(outfile, level, namespace_='link:', name_='footnoteArc', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            footnote_.export(outfile, level, namespace_='link:', name_='footnote', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'documentation':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <documentation> element')
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'documentation':
            obj_ = documentationType.factory()
            obj_.build(child_)
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'loc':
            obj_ = locatorType.factory()
            obj_.build(child_)
            self.loc.append(obj_)
            obj_.original_tagname_ = 'loc'
        elif nodeName_ == 'footnoteArc':
            class_obj_ = self.get_class_obj_(child_, arcType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.footnoteArc.append(obj_)
            obj_.original_tagname_ = 'footnoteArc'
        elif nodeName_ == 'footnote':
            obj_ = footnote.factory()
            obj_.build(child_)
            self.footnote.append(obj_)
            obj_.original_tagname_ = 'footnote'
# end class footnoteLink


class linkbase(GeneratedsSuper):
    """Definition of the linkbase element. Used to contain a set of zero or
    more extended link elements."""
    subclass = None
    superclass = None
    def __init__(self, id=None, documentation=None, roleRef=None, arcroleRef=None, extended=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if documentation is None:
            self.documentation = []
        else:
            self.documentation = documentation
        if roleRef is None:
            self.roleRef = []
        else:
            self.roleRef = roleRef
        if arcroleRef is None:
            self.arcroleRef = []
        else:
            self.arcroleRef = arcroleRef
        if extended is None:
            self.extended = []
        else:
            self.extended = extended
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if linkbase.subclass:
            return linkbase.subclass(*args_, **kwargs_)
        else:
            return linkbase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_documentation(self): return self.documentation
    def set_documentation(self, documentation): self.documentation = documentation
    def add_documentation(self, value): self.documentation.append(value)
    def insert_documentation_at(self, index, value): self.documentation.insert(index, value)
    def replace_documentation_at(self, index, value): self.documentation[index] = value
    def get_roleRef(self): return self.roleRef
    def set_roleRef(self, roleRef): self.roleRef = roleRef
    def add_roleRef(self, value): self.roleRef.append(value)
    def insert_roleRef_at(self, index, value): self.roleRef.insert(index, value)
    def replace_roleRef_at(self, index, value): self.roleRef[index] = value
    def get_arcroleRef(self): return self.arcroleRef
    def set_arcroleRef(self, arcroleRef): self.arcroleRef = arcroleRef
    def add_arcroleRef(self, value): self.arcroleRef.append(value)
    def insert_arcroleRef_at(self, index, value): self.arcroleRef.insert(index, value)
    def replace_arcroleRef_at(self, index, value): self.arcroleRef[index] = value
    def get_extended(self): return self.extended
    def set_extended(self, extended): self.extended = extended
    def add_extended(self, value): self.extended.append(value)
    def insert_extended_at(self, index, value): self.extended.insert(index, value)
    def replace_extended_at(self, index, value): self.extended[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.documentation or
            self.roleRef or
            self.arcroleRef or
            self.extended
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='linkbase', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xl="http://www.xbrl.org/2003/XLink" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='linkbase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='linkbase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='linkbase'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='linkbase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for documentation_ in self.documentation:
            documentation_.export(outfile, level, namespace_, name_='documentation', pretty_print=pretty_print)
        for roleRef_ in self.roleRef:
            roleRef_.export(outfile, level, namespace_='link:', name_='roleRef', pretty_print=pretty_print)
        for arcroleRef_ in self.arcroleRef:
            arcroleRef_.export(outfile, level, namespace_='link:', name_='arcroleRef', pretty_print=pretty_print)
        for extended_ in self.extended:
            extended_.export(outfile, level, namespace_, name_='extended', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'documentation':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <documentation> element')
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'documentation':
            obj_ = documentationType.factory()
            obj_.build(child_)
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'roleRef':
            obj_ = roleRef.factory()
            obj_.build(child_)
            self.roleRef.append(obj_)
            obj_.original_tagname_ = 'roleRef'
        elif nodeName_ == 'arcroleRef':
            obj_ = arcroleRef.factory()
            obj_.build(child_)
            self.arcroleRef.append(obj_)
            obj_.original_tagname_ = 'arcroleRef'
        elif nodeName_ == 'extended':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <extended> element')
            self.extended.append(obj_)
            obj_.original_tagname_ = 'extended'
        elif nodeName_ == 'presentationLink':
            obj_ = presentationLink.factory()
            obj_.build(child_)
            self.extended.append(obj_)
            obj_.original_tagname_ = 'presentationLink'
        elif nodeName_ == 'definitionLink':
            obj_ = definitionLink.factory()
            obj_.build(child_)
            self.extended.append(obj_)
            obj_.original_tagname_ = 'definitionLink'
        elif nodeName_ == 'calculationLink':
            obj_ = calculationLink.factory()
            obj_.build(child_)
            self.extended.append(obj_)
            obj_.original_tagname_ = 'calculationLink'
        elif nodeName_ == 'labelLink':
            obj_ = labelLink.factory()
            obj_.build(child_)
            self.extended.append(obj_)
            obj_.original_tagname_ = 'labelLink'
        elif nodeName_ == 'referenceLink':
            obj_ = referenceLink.factory()
            obj_.build(child_)
            self.extended.append(obj_)
            obj_.original_tagname_ = 'referenceLink'
        elif nodeName_ == 'footnoteLink':
            obj_ = footnoteLink.factory()
            obj_.build(child_)
            self.extended.append(obj_)
            obj_.original_tagname_ = 'footnoteLink'
# end class linkbase


class linkbaseRef(GeneratedsSuper):
    """Definition of the linkbaseRef element - used to link to XBRL
    taxonomy extended links from taxonomy schema documents and from
    XBRL instances. This attribute must have the value:
    http://www.w3.org/1999/xlink/properties/linkbase"""
    subclass = None
    superclass = None
    def __init__(self, arcrole=None):
        self.original_tagname_ = None
        self.arcrole = _cast(None, arcrole)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if linkbaseRef.subclass:
            return linkbaseRef.subclass(*args_, **kwargs_)
        else:
            return linkbaseRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='linkbaseRef', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='linkbaseRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='linkbaseRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='linkbaseRef'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='linkbaseRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class linkbaseRef


class roleType(GeneratedsSuper):
    """The roleType element definition - used to define custom role values
    in XBRL extended links."""
    subclass = None
    superclass = None
    def __init__(self, roleURI=None, id=None, definition=None, usedOn=None):
        self.original_tagname_ = None
        self.roleURI = _cast(None, roleURI)
        self.id = _cast(None, id)
        self.definition = definition
        if usedOn is None:
            self.usedOn = []
        else:
            self.usedOn = usedOn
    def factory(*args_, **kwargs_):
        if roleType.subclass:
            return roleType.subclass(*args_, **kwargs_)
        else:
            return roleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_definition(self): return self.definition
    def set_definition(self, definition): self.definition = definition
    def get_usedOn(self): return self.usedOn
    def set_usedOn(self, usedOn): self.usedOn = usedOn
    def add_usedOn(self, value): self.usedOn.append(value)
    def insert_usedOn_at(self, index, value): self.usedOn.insert(index, value)
    def replace_usedOn_at(self, index, value): self.usedOn[index] = value
    def get_roleURI(self): return self.roleURI
    def set_roleURI(self, roleURI): self.roleURI = roleURI
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.definition is not None or
            self.usedOn
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='roleType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='roleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='roleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='roleType'):
        if self.roleURI is not None and 'roleURI' not in already_processed:
            already_processed.add('roleURI')
            outfile.write(' roleURI=%s' % (quote_attrib(self.roleURI), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='roleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.definition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefinition>%s</%sdefinition>%s' % (namespace_, self.gds_format_string(quote_xml(self.definition).encode(ExternalEncoding), input_name='definition'), namespace_, eol_))
        for usedOn_ in self.usedOn:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susedOn>%s</%susedOn>%s' % (namespace_, self.gds_format_string(quote_xml(usedOn_).encode(ExternalEncoding), input_name='usedOn'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('roleURI', node)
        if value is not None and 'roleURI' not in already_processed:
            already_processed.add('roleURI')
            self.roleURI = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'definition':
            definition_ = child_.text
            definition_ = self.gds_validate_string(definition_, node, 'definition')
            self.definition = definition_
        elif nodeName_ == 'usedOn':
            usedOn_ = child_.text
            usedOn_ = self.gds_validate_string(usedOn_, node, 'usedOn')
            self.usedOn.append(usedOn_)
# end class roleType


class arcroleType(GeneratedsSuper):
    """The arcroleType element definition - used to define custom arc role
    values in XBRL extended links."""
    subclass = None
    superclass = None
    def __init__(self, arcroleURI=None, id=None, cyclesAllowed=None, definition=None, usedOn=None):
        self.original_tagname_ = None
        self.arcroleURI = _cast(None, arcroleURI)
        self.id = _cast(None, id)
        self.cyclesAllowed = _cast(None, cyclesAllowed)
        self.definition = definition
        if usedOn is None:
            self.usedOn = []
        else:
            self.usedOn = usedOn
    def factory(*args_, **kwargs_):
        if arcroleType.subclass:
            return arcroleType.subclass(*args_, **kwargs_)
        else:
            return arcroleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_definition(self): return self.definition
    def set_definition(self, definition): self.definition = definition
    def get_usedOn(self): return self.usedOn
    def set_usedOn(self, usedOn): self.usedOn = usedOn
    def add_usedOn(self, value): self.usedOn.append(value)
    def insert_usedOn_at(self, index, value): self.usedOn.insert(index, value)
    def replace_usedOn_at(self, index, value): self.usedOn[index] = value
    def get_arcroleURI(self): return self.arcroleURI
    def set_arcroleURI(self, arcroleURI): self.arcroleURI = arcroleURI
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_cyclesAllowed(self): return self.cyclesAllowed
    def set_cyclesAllowed(self, cyclesAllowed): self.cyclesAllowed = cyclesAllowed
    def hasContent_(self):
        if (
            self.definition is not None or
            self.usedOn
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='arcroleType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='arcroleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='arcroleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='arcroleType'):
        if self.arcroleURI is not None and 'arcroleURI' not in already_processed:
            already_processed.add('arcroleURI')
            outfile.write(' arcroleURI=%s' % (quote_attrib(self.arcroleURI), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.cyclesAllowed is not None and 'cyclesAllowed' not in already_processed:
            already_processed.add('cyclesAllowed')
            outfile.write(' cyclesAllowed=%s' % (quote_attrib(self.cyclesAllowed), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='arcroleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.definition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefinition>%s</%sdefinition>%s' % (namespace_, self.gds_format_string(quote_xml(self.definition).encode(ExternalEncoding), input_name='definition'), namespace_, eol_))
        for usedOn_ in self.usedOn:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susedOn>%s</%susedOn>%s' % (namespace_, self.gds_format_string(quote_xml(usedOn_).encode(ExternalEncoding), input_name='usedOn'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('arcroleURI', node)
        if value is not None and 'arcroleURI' not in already_processed:
            already_processed.add('arcroleURI')
            self.arcroleURI = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('cyclesAllowed', node)
        if value is not None and 'cyclesAllowed' not in already_processed:
            already_processed.add('cyclesAllowed')
            self.cyclesAllowed = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'definition':
            definition_ = child_.text
            definition_ = self.gds_validate_string(definition_, node, 'definition')
            self.definition = definition_
        elif nodeName_ == 'usedOn':
            usedOn_ = child_.text
            usedOn_ = self.gds_validate_string(usedOn_, node, 'usedOn')
            self.usedOn.append(usedOn_)
# end class arcroleType


class documentationType(GeneratedsSuper):
    """Element type to use for documentation of extended links and
    linkbases."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if documentationType.subclass:
            return documentationType.subclass(*args_, **kwargs_)
        else:
            return documentationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='documentationType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='documentationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='documentationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='documentationType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='documentationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class documentationType


class titleType(GeneratedsSuper):
    """Type for the abstract title element - used as a title element
    template."""
    subclass = None
    superclass = None
    def __init__(self, type_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if titleType.subclass:
            return titleType.subclass(*args_, **kwargs_)
        else:
            return titleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='titleType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='titleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='titleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='titleType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='titleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class titleType


class locatorType(GeneratedsSuper):
    """Generic locator type."""
    subclass = None
    superclass = None
    def __init__(self, title_attr=None, label=None, href=None, role=None, type_=None, title=None):
        self.original_tagname_ = None
        self.title_attr = _cast(None, title_attr)
        self.label = _cast(None, label)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.type_ = _cast(None, type_)
        if title is None:
            self.title = []
        else:
            self.title = title
    def factory(*args_, **kwargs_):
        if locatorType.subclass:
            return locatorType.subclass(*args_, **kwargs_)
        else:
            return locatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title_at(self, index, value): self.title.insert(index, value)
    def replace_title_at(self, index, value): self.title[index] = value
    def get_title_attr(self): return self.title_attr
    def set_title_attr(self, title_attr): self.title_attr = title_attr
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.title
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='locatorType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xl="http://www.xbrl.org/2003/XLink" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='locatorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='locatorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='locatorType'):
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title_attr).encode(ExternalEncoding), input_name='title_attr'), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (quote_attrib(self.label), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='locatorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('title', node)
        if value is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            self.title_attr = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
# end class locatorType


class arcType(GeneratedsSuper):
    """basic extended link arc type - extended where necessary for specific
    arcs Extends the generic arc type by adding use, priority and
    order attributes."""
    subclass = None
    superclass = None
    def __init__(self, use=None, from_=None, title_attr=None, show=None, arcrole=None, actuate=None, priority=None, to=None, type_=None, order=None, title=None, extensiontype_=None):
        self.original_tagname_ = None
        self.use = _cast(None, use)
        self.from_ = _cast(None, from_)
        self.title_attr = _cast(None, title_attr)
        self.show = _cast(None, show)
        self.arcrole = _cast(None, arcrole)
        self.actuate = _cast(None, actuate)
        self.priority = _cast(None, priority)
        self.to = _cast(None, to)
        self.type_ = _cast(None, type_)
        self.order = _cast(None, order)
        if title is None:
            self.title = []
        else:
            self.title = title
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if arcType.subclass:
            return arcType.subclass(*args_, **kwargs_)
        else:
            return arcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title_at(self, index, value): self.title.insert(index, value)
    def replace_title_at(self, index, value): self.title[index] = value
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def get_from(self): return self.from_
    def set_from(self, from_): self.from_ = from_
    def get_title_attr(self): return self.title_attr
    def set_title_attr(self, title_attr): self.title_attr = title_attr
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    def get_priority(self): return self.priority
    def set_priority(self, priority): self.priority = priority
    def get_to(self): return self.to
    def set_to(self, to): self.to = to
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_order(self): return self.order
    def set_order(self, order): self.order = order
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.title
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='arcType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xl="http://www.xbrl.org/2003/XLink" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='arcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='arcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='arcType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from=%s' % (quote_attrib(self.from_), ))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title_attr).encode(ExternalEncoding), input_name='title_attr'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            outfile.write(' priority=%s' % (quote_attrib(self.priority), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.add('to')
            outfile.write(' to=%s' % (quote_attrib(self.to), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order=%s' % (quote_attrib(self.order), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='arcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = value
        value = find_attr_value_('title', node)
        if value is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            self.title_attr = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('priority', node)
        if value is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            self.priority = value
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.add('to')
            self.to = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            self.order = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
# end class arcType


class resourceType(GeneratedsSuper):
    """Generic type for the resource type element"""
    subclass = None
    superclass = None
    def __init__(self, role=None, title=None, type_=None, id=None, label=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.role = _cast(None, role)
        self.title = _cast(None, title)
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.label = _cast(None, label)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if resourceType.subclass:
            return resourceType.subclass(*args_, **kwargs_)
        else:
            return resourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='resourceType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resourceType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='resourceType'):
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (quote_attrib(self.label), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='resourceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class resourceType


class extendedType(GeneratedsSuper):
    """Generic extended link type"""
    subclass = None
    superclass = None
    def __init__(self, role=None, type_=None, id=None, title_attr=None, title=None, documentation=None, locator=None, arc=None, resource=None):
        self.original_tagname_ = None
        self.role = _cast(None, role)
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.title_attr = _cast(None, title_attr)
        if title is None:
            self.title = []
        else:
            self.title = title
        if documentation is None:
            self.documentation = []
        else:
            self.documentation = documentation
        if locator is None:
            self.locator = []
        else:
            self.locator = locator
        if arc is None:
            self.arc = []
        else:
            self.arc = arc
        if resource is None:
            self.resource = []
        else:
            self.resource = resource
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if extendedType.subclass:
            return extendedType.subclass(*args_, **kwargs_)
        else:
            return extendedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title_at(self, index, value): self.title.insert(index, value)
    def replace_title_at(self, index, value): self.title[index] = value
    def get_documentation(self): return self.documentation
    def set_documentation(self, documentation): self.documentation = documentation
    def add_documentation(self, value): self.documentation.append(value)
    def insert_documentation_at(self, index, value): self.documentation.insert(index, value)
    def replace_documentation_at(self, index, value): self.documentation[index] = value
    def get_locator(self): return self.locator
    def set_locator(self, locator): self.locator = locator
    def add_locator(self, value): self.locator.append(value)
    def insert_locator_at(self, index, value): self.locator.insert(index, value)
    def replace_locator_at(self, index, value): self.locator[index] = value
    def get_arc(self): return self.arc
    def set_arc(self, arc): self.arc = arc
    def add_arc(self, value): self.arc.append(value)
    def insert_arc_at(self, index, value): self.arc.insert(index, value)
    def replace_arc_at(self, index, value): self.arc[index] = value
    def get_resource(self): return self.resource
    def set_resource(self, resource): self.resource = resource
    def add_resource(self, value): self.resource.append(value)
    def insert_resource_at(self, index, value): self.resource.insert(index, value)
    def replace_resource_at(self, index, value): self.resource[index] = value
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_title_attr(self): return self.title_attr
    def set_title_attr(self, title_attr): self.title_attr = title_attr
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.title or
            self.documentation or
            self.locator or
            self.arc or
            self.resource
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='extendedType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:xl="http://www.xbrl.org/2003/XLink" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='extendedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='extendedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='extendedType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title_attr).encode(ExternalEncoding), input_name='title_attr'), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='extendedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for documentation_ in self.documentation:
            documentation_.export(outfile, level, namespace_, name_='documentation', pretty_print=pretty_print)
        for locator_ in self.locator:
            locator_.export(outfile, level, namespace_, name_='locator', pretty_print=pretty_print)
        for arc_ in self.arc:
            arc_.export(outfile, level, namespace_, name_='arc', pretty_print=pretty_print)
        for resource_ in self.resource:
            resource_.export(outfile, level, namespace_, name_='resource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('title', node)
        if value is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            self.title_attr = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <title> element')
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'documentation':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <documentation> element')
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'documentation':
            obj_ = documentationType.factory()
            obj_.build(child_)
            self.documentation.append(obj_)
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'locator':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <locator> element')
            self.locator.append(obj_)
            obj_.original_tagname_ = 'locator'
        elif nodeName_ == 'loc':
            obj_ = locatorType.factory()
            obj_.build(child_)
            self.locator.append(obj_)
            obj_.original_tagname_ = 'loc'
        elif nodeName_ == 'arc':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <arc> element')
            self.arc.append(obj_)
            obj_.original_tagname_ = 'arc'
        elif nodeName_ == 'labelArc':
            class_obj_ = self.get_class_obj_(child_, arcType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.arc.append(obj_)
            obj_.original_tagname_ = 'labelArc'
        elif nodeName_ == 'referenceArc':
            class_obj_ = self.get_class_obj_(child_, arcType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.arc.append(obj_)
            obj_.original_tagname_ = 'referenceArc'
        elif nodeName_ == 'definitionArc':
            class_obj_ = self.get_class_obj_(child_, arcType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.arc.append(obj_)
            obj_.original_tagname_ = 'definitionArc'
        elif nodeName_ == 'presentationArc':
            obj_ = presentationArc.factory()
            obj_.build(child_)
            self.arc.append(obj_)
            obj_.original_tagname_ = 'presentationArc'
        elif nodeName_ == 'calculationArc':
            obj_ = calculationArc.factory()
            obj_.build(child_)
            self.arc.append(obj_)
            obj_.original_tagname_ = 'calculationArc'
        elif nodeName_ == 'footnoteArc':
            class_obj_ = self.get_class_obj_(child_, arcType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.arc.append(obj_)
            obj_.original_tagname_ = 'footnoteArc'
        elif nodeName_ == 'resource':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <resource> element')
            self.resource.append(obj_)
            obj_.original_tagname_ = 'resource'
        elif nodeName_ == 'label':
            obj_ = label.factory()
            obj_.build(child_)
            self.resource.append(obj_)
            obj_.original_tagname_ = 'label'
        elif nodeName_ == 'reference':
            obj_ = reference.factory()
            obj_.build(child_)
            self.resource.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'footnote':
            obj_ = footnote.factory()
            obj_.build(child_)
            self.resource.append(obj_)
            obj_.original_tagname_ = 'footnote'
# end class extendedType


class simpleType(GeneratedsSuper):
    """Type for the simple links defined in XBRL"""
    subclass = None
    superclass = None
    def __init__(self, show=None, title=None, actuate=None, href=None, role=None, arcrole=None, type_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.show = _cast(None, show)
        self.title = _cast(None, title)
        self.actuate = _cast(None, actuate)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.type_ = _cast(None, type_)
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if simpleType.subclass:
            return simpleType.subclass(*args_, **kwargs_)
        else:
            return simpleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='simpleType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='simpleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='simpleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='simpleType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='simpleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class simpleType


class accountPurposeCodeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(accountPurposeCodeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if accountPurposeCodeItemType.subclass:
            return accountPurposeCodeItemType.subclass(*args_, **kwargs_)
        else:
            return accountPurposeCodeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(accountPurposeCodeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='accountPurposeCodeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accountPurposeCodeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='accountPurposeCodeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='accountPurposeCodeItemType'):
        super(accountPurposeCodeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='accountPurposeCodeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='accountPurposeCodeItemType', fromsubclass_=False, pretty_print=True):
        super(accountPurposeCodeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(accountPurposeCodeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class accountPurposeCodeItemType


class accountTypeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(accountTypeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if accountTypeItemType.subclass:
            return accountTypeItemType.subclass(*args_, **kwargs_)
        else:
            return accountTypeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(accountTypeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='accountTypeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accountTypeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='accountTypeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='accountTypeItemType'):
        super(accountTypeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='accountTypeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='accountTypeItemType', fromsubclass_=False, pretty_print=True):
        super(accountTypeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(accountTypeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class accountTypeItemType


class bookTaxDifferenceItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(bookTaxDifferenceItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if bookTaxDifferenceItemType.subclass:
            return bookTaxDifferenceItemType.subclass(*args_, **kwargs_)
        else:
            return bookTaxDifferenceItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(bookTaxDifferenceItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='bookTaxDifferenceItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bookTaxDifferenceItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='bookTaxDifferenceItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='bookTaxDifferenceItemType'):
        super(bookTaxDifferenceItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='bookTaxDifferenceItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='bookTaxDifferenceItemType', fromsubclass_=False, pretty_print=True):
        super(bookTaxDifferenceItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(bookTaxDifferenceItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class bookTaxDifferenceItemType


class identifierOrganizationTypeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(identifierOrganizationTypeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if identifierOrganizationTypeItemType.subclass:
            return identifierOrganizationTypeItemType.subclass(*args_, **kwargs_)
        else:
            return identifierOrganizationTypeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(identifierOrganizationTypeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='identifierOrganizationTypeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='identifierOrganizationTypeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='identifierOrganizationTypeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='identifierOrganizationTypeItemType'):
        super(identifierOrganizationTypeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='identifierOrganizationTypeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='identifierOrganizationTypeItemType', fromsubclass_=False, pretty_print=True):
        super(identifierOrganizationTypeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(identifierOrganizationTypeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class identifierOrganizationTypeItemType


class debitCreditCodeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(debitCreditCodeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if debitCreditCodeItemType.subclass:
            return debitCreditCodeItemType.subclass(*args_, **kwargs_)
        else:
            return debitCreditCodeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(debitCreditCodeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='debitCreditCodeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='debitCreditCodeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='debitCreditCodeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='debitCreditCodeItemType'):
        super(debitCreditCodeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='debitCreditCodeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='debitCreditCodeItemType', fromsubclass_=False, pretty_print=True):
        super(debitCreditCodeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(debitCreditCodeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class debitCreditCodeItemType


class documentTypeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(documentTypeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if documentTypeItemType.subclass:
            return documentTypeItemType.subclass(*args_, **kwargs_)
        else:
            return documentTypeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(documentTypeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='documentTypeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='documentTypeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='documentTypeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='documentTypeItemType'):
        super(documentTypeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='documentTypeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='documentTypeItemType', fromsubclass_=False, pretty_print=True):
        super(documentTypeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(documentTypeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class documentTypeItemType


class invoiceTypeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(invoiceTypeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if invoiceTypeItemType.subclass:
            return invoiceTypeItemType.subclass(*args_, **kwargs_)
        else:
            return invoiceTypeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(invoiceTypeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='invoiceTypeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='invoiceTypeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='invoiceTypeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='invoiceTypeItemType'):
        super(invoiceTypeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='invoiceTypeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='invoiceTypeItemType', fromsubclass_=False, pretty_print=True):
        super(invoiceTypeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(invoiceTypeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class invoiceTypeItemType


class entriesTypeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(entriesTypeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if entriesTypeItemType.subclass:
            return entriesTypeItemType.subclass(*args_, **kwargs_)
        else:
            return entriesTypeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(entriesTypeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='entriesTypeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entriesTypeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='entriesTypeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='entriesTypeItemType'):
        super(entriesTypeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='entriesTypeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='entriesTypeItemType', fromsubclass_=False, pretty_print=True):
        super(entriesTypeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(entriesTypeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class entriesTypeItemType


class entryTypeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(entryTypeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if entryTypeItemType.subclass:
            return entryTypeItemType.subclass(*args_, **kwargs_)
        else:
            return entryTypeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(entryTypeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='entryTypeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entryTypeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='entryTypeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='entryTypeItemType'):
        super(entryTypeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='entryTypeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='entryTypeItemType', fromsubclass_=False, pretty_print=True):
        super(entryTypeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(entryTypeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class entryTypeItemType


class identifierTypeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(identifierTypeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if identifierTypeItemType.subclass:
            return identifierTypeItemType.subclass(*args_, **kwargs_)
        else:
            return identifierTypeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(identifierTypeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='identifierTypeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='identifierTypeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='identifierTypeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='identifierTypeItemType'):
        super(identifierTypeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='identifierTypeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='identifierTypeItemType', fromsubclass_=False, pretty_print=True):
        super(identifierTypeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(identifierTypeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class identifierTypeItemType


class mainAccountTypeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(mainAccountTypeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if mainAccountTypeItemType.subclass:
            return mainAccountTypeItemType.subclass(*args_, **kwargs_)
        else:
            return mainAccountTypeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(mainAccountTypeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='mainAccountTypeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mainAccountTypeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='mainAccountTypeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='mainAccountTypeItemType'):
        super(mainAccountTypeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='mainAccountTypeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='mainAccountTypeItemType', fromsubclass_=False, pretty_print=True):
        super(mainAccountTypeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(mainAccountTypeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mainAccountTypeItemType


class postingStatusItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(postingStatusItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if postingStatusItemType.subclass:
            return postingStatusItemType.subclass(*args_, **kwargs_)
        else:
            return postingStatusItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(postingStatusItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='postingStatusItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='postingStatusItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='postingStatusItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='postingStatusItemType'):
        super(postingStatusItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='postingStatusItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='postingStatusItemType', fromsubclass_=False, pretty_print=True):
        super(postingStatusItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(postingStatusItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class postingStatusItemType


class qualifierEntryItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(qualifierEntryItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if qualifierEntryItemType.subclass:
            return qualifierEntryItemType.subclass(*args_, **kwargs_)
        else:
            return qualifierEntryItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(qualifierEntryItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='qualifierEntryItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierEntryItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='qualifierEntryItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='qualifierEntryItemType'):
        super(qualifierEntryItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierEntryItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='qualifierEntryItemType', fromsubclass_=False, pretty_print=True):
        super(qualifierEntryItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(qualifierEntryItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qualifierEntryItemType


class revisesUniqueIDActionItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(revisesUniqueIDActionItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if revisesUniqueIDActionItemType.subclass:
            return revisesUniqueIDActionItemType.subclass(*args_, **kwargs_)
        else:
            return revisesUniqueIDActionItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(revisesUniqueIDActionItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='revisesUniqueIDActionItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='revisesUniqueIDActionItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='revisesUniqueIDActionItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='revisesUniqueIDActionItemType'):
        super(revisesUniqueIDActionItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='revisesUniqueIDActionItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='revisesUniqueIDActionItemType', fromsubclass_=False, pretty_print=True):
        super(revisesUniqueIDActionItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(revisesUniqueIDActionItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class revisesUniqueIDActionItemType


class signOfAmountItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(signOfAmountItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if signOfAmountItemType.subclass:
            return signOfAmountItemType.subclass(*args_, **kwargs_)
        else:
            return signOfAmountItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(signOfAmountItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='signOfAmountItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='signOfAmountItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='signOfAmountItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='signOfAmountItemType'):
        super(signOfAmountItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='signOfAmountItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='signOfAmountItemType', fromsubclass_=False, pretty_print=True):
        super(signOfAmountItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(signOfAmountItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class signOfAmountItemType


class sourceJournalIDItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(sourceJournalIDItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if sourceJournalIDItemType.subclass:
            return sourceJournalIDItemType.subclass(*args_, **kwargs_)
        else:
            return sourceJournalIDItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(sourceJournalIDItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='sourceJournalIDItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sourceJournalIDItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='sourceJournalIDItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='sourceJournalIDItemType'):
        super(sourceJournalIDItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='sourceJournalIDItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='sourceJournalIDItemType', fromsubclass_=False, pretty_print=True):
        super(sourceJournalIDItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(sourceJournalIDItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sourceJournalIDItemType


class xbrlIncludeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(xbrlIncludeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if xbrlIncludeItemType.subclass:
            return xbrlIncludeItemType.subclass(*args_, **kwargs_)
        else:
            return xbrlIncludeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(xbrlIncludeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='xbrlIncludeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xbrlIncludeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='xbrlIncludeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='xbrlIncludeItemType'):
        super(xbrlIncludeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='xbrlIncludeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='xbrlIncludeItemType', fromsubclass_=False, pretty_print=True):
        super(xbrlIncludeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(xbrlIncludeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xbrlIncludeItemType


class phoneNumberDescriptionItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(phoneNumberDescriptionItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if phoneNumberDescriptionItemType.subclass:
            return phoneNumberDescriptionItemType.subclass(*args_, **kwargs_)
        else:
            return phoneNumberDescriptionItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(phoneNumberDescriptionItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='phoneNumberDescriptionItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='phoneNumberDescriptionItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='phoneNumberDescriptionItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='phoneNumberDescriptionItemType'):
        super(phoneNumberDescriptionItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='phoneNumberDescriptionItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='phoneNumberDescriptionItemType', fromsubclass_=False, pretty_print=True):
        super(phoneNumberDescriptionItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(phoneNumberDescriptionItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class phoneNumberDescriptionItemType


class availableTypeCodeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(availableTypeCodeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if availableTypeCodeItemType.subclass:
            return availableTypeCodeItemType.subclass(*args_, **kwargs_)
        else:
            return availableTypeCodeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(availableTypeCodeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='availableTypeCodeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='availableTypeCodeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='availableTypeCodeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='availableTypeCodeItemType'):
        super(availableTypeCodeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='availableTypeCodeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='availableTypeCodeItemType', fromsubclass_=False, pretty_print=True):
        super(availableTypeCodeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(availableTypeCodeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class availableTypeCodeItemType


class TreasuryAccountSymbolComplexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, agency=None, allocationTransferAgencyIdentifier=None, mainAccountNumber=None, subAccountSymbol=None, beginningPeriodOfAvailability=None, endingPeriodOfAvailability=None, availabilityTypeCode=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.agency = agency
        if allocationTransferAgencyIdentifier is None:
            self.allocationTransferAgencyIdentifier = []
        else:
            self.allocationTransferAgencyIdentifier = allocationTransferAgencyIdentifier
        self.mainAccountNumber = mainAccountNumber
        if subAccountSymbol is None:
            self.subAccountSymbol = []
        else:
            self.subAccountSymbol = subAccountSymbol
        if beginningPeriodOfAvailability is None:
            self.beginningPeriodOfAvailability = []
        else:
            self.beginningPeriodOfAvailability = beginningPeriodOfAvailability
        if endingPeriodOfAvailability is None:
            self.endingPeriodOfAvailability = []
        else:
            self.endingPeriodOfAvailability = endingPeriodOfAvailability
        self.availabilityTypeCode = availabilityTypeCode
    def factory(*args_, **kwargs_):
        if TreasuryAccountSymbolComplexType.subclass:
            return TreasuryAccountSymbolComplexType.subclass(*args_, **kwargs_)
        else:
            return TreasuryAccountSymbolComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agency(self): return self.agency
    def set_agency(self, agency): self.agency = agency
    def get_allocationTransferAgencyIdentifier(self): return self.allocationTransferAgencyIdentifier
    def set_allocationTransferAgencyIdentifier(self, allocationTransferAgencyIdentifier): self.allocationTransferAgencyIdentifier = allocationTransferAgencyIdentifier
    def add_allocationTransferAgencyIdentifier(self, value): self.allocationTransferAgencyIdentifier.append(value)
    def insert_allocationTransferAgencyIdentifier_at(self, index, value): self.allocationTransferAgencyIdentifier.insert(index, value)
    def replace_allocationTransferAgencyIdentifier_at(self, index, value): self.allocationTransferAgencyIdentifier[index] = value
    def get_mainAccountNumber(self): return self.mainAccountNumber
    def set_mainAccountNumber(self, mainAccountNumber): self.mainAccountNumber = mainAccountNumber
    def get_subAccountSymbol(self): return self.subAccountSymbol
    def set_subAccountSymbol(self, subAccountSymbol): self.subAccountSymbol = subAccountSymbol
    def add_subAccountSymbol(self, value): self.subAccountSymbol.append(value)
    def insert_subAccountSymbol_at(self, index, value): self.subAccountSymbol.insert(index, value)
    def replace_subAccountSymbol_at(self, index, value): self.subAccountSymbol[index] = value
    def get_beginningPeriodOfAvailability(self): return self.beginningPeriodOfAvailability
    def set_beginningPeriodOfAvailability(self, beginningPeriodOfAvailability): self.beginningPeriodOfAvailability = beginningPeriodOfAvailability
    def add_beginningPeriodOfAvailability(self, value): self.beginningPeriodOfAvailability.append(value)
    def insert_beginningPeriodOfAvailability_at(self, index, value): self.beginningPeriodOfAvailability.insert(index, value)
    def replace_beginningPeriodOfAvailability_at(self, index, value): self.beginningPeriodOfAvailability[index] = value
    def get_endingPeriodOfAvailability(self): return self.endingPeriodOfAvailability
    def set_endingPeriodOfAvailability(self, endingPeriodOfAvailability): self.endingPeriodOfAvailability = endingPeriodOfAvailability
    def add_endingPeriodOfAvailability(self, value): self.endingPeriodOfAvailability.append(value)
    def insert_endingPeriodOfAvailability_at(self, index, value): self.endingPeriodOfAvailability.insert(index, value)
    def replace_endingPeriodOfAvailability_at(self, index, value): self.endingPeriodOfAvailability[index] = value
    def get_availabilityTypeCode(self): return self.availabilityTypeCode
    def set_availabilityTypeCode(self, availabilityTypeCode): self.availabilityTypeCode = availabilityTypeCode
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.agency is not None or
            self.allocationTransferAgencyIdentifier or
            self.mainAccountNumber is not None or
            self.subAccountSymbol or
            self.beginningPeriodOfAvailability or
            self.endingPeriodOfAvailability or
            self.availabilityTypeCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='TreasuryAccountSymbolComplexType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:gen="http://www.xbrl.org/int/gl/gen/2006-10-25" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TreasuryAccountSymbolComplexType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='TreasuryAccountSymbolComplexType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='TreasuryAccountSymbolComplexType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='TreasuryAccountSymbolComplexType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.agency is not None:
            self.agency.export(outfile, level, namespace_='gen:', name_='agency', pretty_print=pretty_print)
        for allocationTransferAgencyIdentifier_ in self.allocationTransferAgencyIdentifier:
            allocationTransferAgencyIdentifier_.export(outfile, level, namespace_='gen:', name_='allocationTransferAgencyIdentifier', pretty_print=pretty_print)
        if self.mainAccountNumber is not None:
            self.mainAccountNumber.export(outfile, level, namespace_='gen:', name_='mainAccountNumber', pretty_print=pretty_print)
        for subAccountSymbol_ in self.subAccountSymbol:
            subAccountSymbol_.export(outfile, level, namespace_='gen:', name_='subAccountSymbol', pretty_print=pretty_print)
        for beginningPeriodOfAvailability_ in self.beginningPeriodOfAvailability:
            beginningPeriodOfAvailability_.export(outfile, level, namespace_='gen:', name_='beginningPeriodOfAvailability', pretty_print=pretty_print)
        for endingPeriodOfAvailability_ in self.endingPeriodOfAvailability:
            endingPeriodOfAvailability_.export(outfile, level, namespace_='gen:', name_='endingPeriodOfAvailability', pretty_print=pretty_print)
        if self.availabilityTypeCode is not None:
            self.availabilityTypeCode.export(outfile, level, namespace_='gen:', name_='availabilityTypeCode', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'agency':
            obj_ = agencyComplexType.factory()
            obj_.build(child_)
            self.agency = obj_
            obj_.original_tagname_ = 'agency'
        elif nodeName_ == 'allocationTransferAgencyIdentifier':
            obj_ = integerItemType.factory()
            obj_.build(child_)
            self.allocationTransferAgencyIdentifier.append(obj_)
            obj_.original_tagname_ = 'allocationTransferAgencyIdentifier'
        elif nodeName_ == 'mainAccountNumber':
            obj_ = integerItemType.factory()
            obj_.build(child_)
            self.mainAccountNumber = obj_
            obj_.original_tagname_ = 'mainAccountNumber'
        elif nodeName_ == 'subAccountSymbol':
            obj_ = integerItemType.factory()
            obj_.build(child_)
            self.subAccountSymbol.append(obj_)
            obj_.original_tagname_ = 'subAccountSymbol'
        elif nodeName_ == 'beginningPeriodOfAvailability':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.beginningPeriodOfAvailability.append(obj_)
            obj_.original_tagname_ = 'beginningPeriodOfAvailability'
        elif nodeName_ == 'endingPeriodOfAvailability':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.endingPeriodOfAvailability.append(obj_)
            obj_.original_tagname_ = 'endingPeriodOfAvailability'
        elif nodeName_ == 'availabilityTypeCode':
            obj_ = availableTypeCodeItemType.factory()
            obj_.build(child_)
            self.availabilityTypeCode = obj_
            obj_.original_tagname_ = 'availabilityTypeCode'
# end class TreasuryAccountSymbolComplexType


class addressComplexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, streetAddress=None, city=None, county=None, state=None, postalCode=None, zipCodePlus4=None, countryName=None, countryCode=None, congressionalDistrict=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.streetAddress = streetAddress
        self.city = city
        self.county = county
        self.state = state
        self.postalCode = postalCode
        self.zipCodePlus4 = zipCodePlus4
        self.countryName = countryName
        self.countryCode = countryCode
        self.congressionalDistrict = congressionalDistrict
    def factory(*args_, **kwargs_):
        if addressComplexType.subclass:
            return addressComplexType.subclass(*args_, **kwargs_)
        else:
            return addressComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_streetAddress(self): return self.streetAddress
    def set_streetAddress(self, streetAddress): self.streetAddress = streetAddress
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_county(self): return self.county
    def set_county(self, county): self.county = county
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def get_zipCodePlus4(self): return self.zipCodePlus4
    def set_zipCodePlus4(self, zipCodePlus4): self.zipCodePlus4 = zipCodePlus4
    def get_countryName(self): return self.countryName
    def set_countryName(self, countryName): self.countryName = countryName
    def get_countryCode(self): return self.countryCode
    def set_countryCode(self, countryCode): self.countryCode = countryCode
    def get_congressionalDistrict(self): return self.congressionalDistrict
    def set_congressionalDistrict(self, congressionalDistrict): self.congressionalDistrict = congressionalDistrict
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.streetAddress is not None or
            self.city is not None or
            self.county is not None or
            self.state is not None or
            self.postalCode is not None or
            self.zipCodePlus4 is not None or
            self.countryName is not None or
            self.countryCode is not None or
            self.congressionalDistrict is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='addressComplexType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:gen="http://www.xbrl.org/int/gl/gen/2006-10-25" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='addressComplexType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='addressComplexType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='addressComplexType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='addressComplexType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.streetAddress is not None:
            self.streetAddress.export(outfile, level, namespace_='gen:', name_='streetAddress', pretty_print=pretty_print)
        if self.city is not None:
            self.city.export(outfile, level, namespace_='gen:', name_='city', pretty_print=pretty_print)
        if self.county is not None:
            self.county.export(outfile, level, namespace_='gen:', name_='county', pretty_print=pretty_print)
        if self.state is not None:
            self.state.export(outfile, level, namespace_='gen:', name_='state', pretty_print=pretty_print)
        if self.postalCode is not None:
            self.postalCode.export(outfile, level, namespace_='gen:', name_='postalCode', pretty_print=pretty_print)
        if self.zipCodePlus4 is not None:
            self.zipCodePlus4.export(outfile, level, namespace_='gen:', name_='zipCodePlus4', pretty_print=pretty_print)
        if self.countryName is not None:
            self.countryName.export(outfile, level, namespace_='gen:', name_='countryName', pretty_print=pretty_print)
        if self.countryCode is not None:
            self.countryCode.export(outfile, level, namespace_='gen:', name_='countryCode', pretty_print=pretty_print)
        if self.congressionalDistrict is not None:
            self.congressionalDistrict.export(outfile, level, namespace_='gen:', name_='congressionalDistrict', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'streetAddress':
            obj_ = streetAddressComplexType.factory()
            obj_.build(child_)
            self.streetAddress = obj_
            obj_.original_tagname_ = 'streetAddress'
        elif nodeName_ == 'city':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.city = obj_
            obj_.original_tagname_ = 'city'
        elif nodeName_ == 'county':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.county = obj_
            obj_.original_tagname_ = 'county'
        elif nodeName_ == 'state':
            obj_ = stateItemType.factory()
            obj_.build(child_)
            self.state = obj_
            obj_.original_tagname_ = 'state'
        elif nodeName_ == 'postalCode':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.postalCode = obj_
            obj_.original_tagname_ = 'postalCode'
        elif nodeName_ == 'zipCodePlus4':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.zipCodePlus4 = obj_
            obj_.original_tagname_ = 'zipCodePlus4'
        elif nodeName_ == 'countryName':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.countryName = obj_
            obj_.original_tagname_ = 'countryName'
        elif nodeName_ == 'countryCode':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.countryCode = obj_
            obj_.original_tagname_ = 'countryCode'
        elif nodeName_ == 'congressionalDistrict':
            obj_ = congressionalDistrictItemType.factory()
            obj_.build(child_)
            self.congressionalDistrict = obj_
            obj_.original_tagname_ = 'congressionalDistrict'
# end class addressComplexType


class streetAddressComplexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, streetAddressLine=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if streetAddressLine is None:
            self.streetAddressLine = []
        else:
            self.streetAddressLine = streetAddressLine
    def factory(*args_, **kwargs_):
        if streetAddressComplexType.subclass:
            return streetAddressComplexType.subclass(*args_, **kwargs_)
        else:
            return streetAddressComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_streetAddressLine(self): return self.streetAddressLine
    def set_streetAddressLine(self, streetAddressLine): self.streetAddressLine = streetAddressLine
    def add_streetAddressLine(self, value): self.streetAddressLine.append(value)
    def insert_streetAddressLine_at(self, index, value): self.streetAddressLine.insert(index, value)
    def replace_streetAddressLine_at(self, index, value): self.streetAddressLine[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.streetAddressLine
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='streetAddressComplexType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:gen="http://www.xbrl.org/int/gl/gen/2006-10-25" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streetAddressComplexType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='streetAddressComplexType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='streetAddressComplexType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='streetAddressComplexType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for streetAddressLine_ in self.streetAddressLine:
            streetAddressLine_.export(outfile, level, namespace_='gen:', name_='streetAddressLine', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'streetAddressLine':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.streetAddressLine.append(obj_)
            obj_.original_tagname_ = 'streetAddressLine'
# end class streetAddressComplexType


class agencyComplexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, agencyIdentifier=None, agencyName=None, agencyOffice=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.agencyIdentifier = agencyIdentifier
        self.agencyName = agencyName
        if agencyOffice is None:
            self.agencyOffice = []
        else:
            self.agencyOffice = agencyOffice
    def factory(*args_, **kwargs_):
        if agencyComplexType.subclass:
            return agencyComplexType.subclass(*args_, **kwargs_)
        else:
            return agencyComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agencyIdentifier(self): return self.agencyIdentifier
    def set_agencyIdentifier(self, agencyIdentifier): self.agencyIdentifier = agencyIdentifier
    def get_agencyName(self): return self.agencyName
    def set_agencyName(self, agencyName): self.agencyName = agencyName
    def get_agencyOffice(self): return self.agencyOffice
    def set_agencyOffice(self, agencyOffice): self.agencyOffice = agencyOffice
    def add_agencyOffice(self, value): self.agencyOffice.append(value)
    def insert_agencyOffice_at(self, index, value): self.agencyOffice.insert(index, value)
    def replace_agencyOffice_at(self, index, value): self.agencyOffice[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.agencyIdentifier is not None or
            self.agencyName is not None or
            self.agencyOffice
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='agencyComplexType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:gen="http://www.xbrl.org/int/gl/gen/2006-10-25" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='agencyComplexType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='agencyComplexType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='agencyComplexType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='agencyComplexType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.agencyIdentifier is not None:
            self.agencyIdentifier.export(outfile, level, namespace_='gen:', name_='agencyIdentifier', pretty_print=pretty_print)
        if self.agencyName is not None:
            self.agencyName.export(outfile, level, namespace_='gen:', name_='agencyName', pretty_print=pretty_print)
        for agencyOffice_ in self.agencyOffice:
            agencyOffice_.export(outfile, level, namespace_='gen:', name_='agencyOffice', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'agencyIdentifier':
            obj_ = integerItemType.factory()
            obj_.build(child_)
            self.agencyIdentifier = obj_
            obj_.original_tagname_ = 'agencyIdentifier'
        elif nodeName_ == 'agencyName':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.agencyName = obj_
            obj_.original_tagname_ = 'agencyName'
        elif nodeName_ == 'agencyOffice':
            obj_ = agencyOfficeComplexType.factory()
            obj_.build(child_)
            self.agencyOffice.append(obj_)
            obj_.original_tagname_ = 'agencyOffice'
# end class agencyComplexType


class agencyOfficeComplexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, officeIdentifier=None, officeName=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.officeIdentifier = officeIdentifier
        self.officeName = officeName
    def factory(*args_, **kwargs_):
        if agencyOfficeComplexType.subclass:
            return agencyOfficeComplexType.subclass(*args_, **kwargs_)
        else:
            return agencyOfficeComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_officeIdentifier(self): return self.officeIdentifier
    def set_officeIdentifier(self, officeIdentifier): self.officeIdentifier = officeIdentifier
    def get_officeName(self): return self.officeName
    def set_officeName(self, officeName): self.officeName = officeName
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.officeIdentifier is not None or
            self.officeName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='agencyOfficeComplexType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:gen="http://www.xbrl.org/int/gl/gen/2006-10-25" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='agencyOfficeComplexType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='agencyOfficeComplexType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='agencyOfficeComplexType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='agencyOfficeComplexType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.officeIdentifier is not None:
            self.officeIdentifier.export(outfile, level, namespace_='gen:', name_='officeIdentifier', pretty_print=pretty_print)
        if self.officeName is not None:
            self.officeName.export(outfile, level, namespace_='gen:', name_='officeName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'officeIdentifier':
            obj_ = integerItemType.factory()
            obj_.build(child_)
            self.officeIdentifier = obj_
            obj_.original_tagname_ = 'officeIdentifier'
        elif nodeName_ == 'officeName':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.officeName = obj_
            obj_.original_tagname_ = 'officeName'
# end class agencyOfficeComplexType


class amountItemType(monetaryItemType):
    subclass = None
    superclass = monetaryItemType
    def __init__(self, unitRef=None, decimals=None, id=None, contextRef=None, precision=None, valueOf_=None):
        self.original_tagname_ = None
        super(amountItemType, self).__init__(unitRef, decimals, id, contextRef, precision, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if amountItemType.subclass:
            return amountItemType.subclass(*args_, **kwargs_)
        else:
            return amountItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(amountItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='amountItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='amountItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='amountItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='amountItemType'):
        super(amountItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='amountItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='amountItemType', fromsubclass_=False, pretty_print=True):
        super(amountItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(amountItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class amountItemType


class congressionalDistrictItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(congressionalDistrictItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if congressionalDistrictItemType.subclass:
            return congressionalDistrictItemType.subclass(*args_, **kwargs_)
        else:
            return congressionalDistrictItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(congressionalDistrictItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='congressionalDistrictItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='congressionalDistrictItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='congressionalDistrictItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='congressionalDistrictItemType'):
        super(congressionalDistrictItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='congressionalDistrictItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='congressionalDistrictItemType', fromsubclass_=False, pretty_print=True):
        super(congressionalDistrictItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(congressionalDistrictItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class congressionalDistrictItemType


class stateItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(stateItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if stateItemType.subclass:
            return stateItemType.subclass(*args_, **kwargs_)
        else:
            return stateItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(stateItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='stateItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stateItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='stateItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='stateItemType'):
        super(stateItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='stateItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='stateItemType', fromsubclass_=False, pretty_print=True):
        super(stateItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(stateItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class stateItemType


class businessTypeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(businessTypeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if businessTypeItemType.subclass:
            return businessTypeItemType.subclass(*args_, **kwargs_)
        else:
            return businessTypeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(businessTypeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='businessTypeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='businessTypeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='businessTypeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='businessTypeItemType'):
        super(businessTypeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='businessTypeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='businessTypeItemType', fromsubclass_=False, pretty_print=True):
        super(businessTypeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(businessTypeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class businessTypeItemType


class recordTypeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(recordTypeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if recordTypeItemType.subclass:
            return recordTypeItemType.subclass(*args_, **kwargs_)
        else:
            return recordTypeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(recordTypeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='recordTypeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recordTypeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='recordTypeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='recordTypeItemType'):
        super(recordTypeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='recordTypeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='recordTypeItemType', fromsubclass_=False, pretty_print=True):
        super(recordTypeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(recordTypeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class recordTypeItemType


class typeOfActionItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(typeOfActionItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if typeOfActionItemType.subclass:
            return typeOfActionItemType.subclass(*args_, **kwargs_)
        else:
            return typeOfActionItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(typeOfActionItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='typeOfActionItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='typeOfActionItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='typeOfActionItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='typeOfActionItemType'):
        super(typeOfActionItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='typeOfActionItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='typeOfActionItemType', fromsubclass_=False, pretty_print=True):
        super(typeOfActionItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(typeOfActionItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class typeOfActionItemType


class typeOfTransactionCodeItemType(tokenItemType):
    subclass = None
    superclass = tokenItemType
    def __init__(self, id=None, contextRef=None, valueOf_=None):
        self.original_tagname_ = None
        super(typeOfTransactionCodeItemType, self).__init__(id, contextRef, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if typeOfTransactionCodeItemType.subclass:
            return typeOfTransactionCodeItemType.subclass(*args_, **kwargs_)
        else:
            return typeOfTransactionCodeItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(typeOfTransactionCodeItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='typeOfTransactionCodeItemType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='typeOfTransactionCodeItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='typeOfTransactionCodeItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='typeOfTransactionCodeItemType'):
        super(typeOfTransactionCodeItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='typeOfTransactionCodeItemType')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='typeOfTransactionCodeItemType', fromsubclass_=False, pretty_print=True):
        super(typeOfTransactionCodeItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(typeOfTransactionCodeItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class typeOfTransactionCodeItemType


class highlyCompensatedOfficerComplexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, highlyCompensatedOfficerFirstName=None, highlyCompensatedOfficerMiddleInitial=None, highlyCompensatedOfficerLastName=None, highlyCompensatedOfficerCompensation=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.highlyCompensatedOfficerFirstName = highlyCompensatedOfficerFirstName
        self.highlyCompensatedOfficerMiddleInitial = highlyCompensatedOfficerMiddleInitial
        self.highlyCompensatedOfficerLastName = highlyCompensatedOfficerLastName
        self.highlyCompensatedOfficerCompensation = highlyCompensatedOfficerCompensation
    def factory(*args_, **kwargs_):
        if highlyCompensatedOfficerComplexType.subclass:
            return highlyCompensatedOfficerComplexType.subclass(*args_, **kwargs_)
        else:
            return highlyCompensatedOfficerComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_highlyCompensatedOfficerFirstName(self): return self.highlyCompensatedOfficerFirstName
    def set_highlyCompensatedOfficerFirstName(self, highlyCompensatedOfficerFirstName): self.highlyCompensatedOfficerFirstName = highlyCompensatedOfficerFirstName
    def get_highlyCompensatedOfficerMiddleInitial(self): return self.highlyCompensatedOfficerMiddleInitial
    def set_highlyCompensatedOfficerMiddleInitial(self, highlyCompensatedOfficerMiddleInitial): self.highlyCompensatedOfficerMiddleInitial = highlyCompensatedOfficerMiddleInitial
    def get_highlyCompensatedOfficerLastName(self): return self.highlyCompensatedOfficerLastName
    def set_highlyCompensatedOfficerLastName(self, highlyCompensatedOfficerLastName): self.highlyCompensatedOfficerLastName = highlyCompensatedOfficerLastName
    def get_highlyCompensatedOfficerCompensation(self): return self.highlyCompensatedOfficerCompensation
    def set_highlyCompensatedOfficerCompensation(self, highlyCompensatedOfficerCompensation): self.highlyCompensatedOfficerCompensation = highlyCompensatedOfficerCompensation
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.highlyCompensatedOfficerFirstName is not None or
            self.highlyCompensatedOfficerMiddleInitial is not None or
            self.highlyCompensatedOfficerLastName is not None or
            self.highlyCompensatedOfficerCompensation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='highlyCompensatedOfficerComplexType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25" xmlns:award="http://www.xbrl.org/int/award/2006-10-25" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='highlyCompensatedOfficerComplexType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='highlyCompensatedOfficerComplexType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='highlyCompensatedOfficerComplexType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='highlyCompensatedOfficerComplexType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.highlyCompensatedOfficerFirstName is not None:
            self.highlyCompensatedOfficerFirstName.export(outfile, level, namespace_='award:', name_='highlyCompensatedOfficerFirstName', pretty_print=pretty_print)
        if self.highlyCompensatedOfficerMiddleInitial is not None:
            self.highlyCompensatedOfficerMiddleInitial.export(outfile, level, namespace_='award:', name_='highlyCompensatedOfficerMiddleInitial', pretty_print=pretty_print)
        if self.highlyCompensatedOfficerLastName is not None:
            self.highlyCompensatedOfficerLastName.export(outfile, level, namespace_='award:', name_='highlyCompensatedOfficerLastName', pretty_print=pretty_print)
        if self.highlyCompensatedOfficerCompensation is not None:
            self.highlyCompensatedOfficerCompensation.export(outfile, level, namespace_='award:', name_='highlyCompensatedOfficerCompensation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'highlyCompensatedOfficerFirstName':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.highlyCompensatedOfficerFirstName = obj_
            obj_.original_tagname_ = 'highlyCompensatedOfficerFirstName'
        elif nodeName_ == 'highlyCompensatedOfficerMiddleInitial':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.highlyCompensatedOfficerMiddleInitial = obj_
            obj_.original_tagname_ = 'highlyCompensatedOfficerMiddleInitial'
        elif nodeName_ == 'highlyCompensatedOfficerLastName':
            obj_ = stringItemType.factory()
            obj_.build(child_)
            self.highlyCompensatedOfficerLastName = obj_
            obj_.original_tagname_ = 'highlyCompensatedOfficerLastName'
        elif nodeName_ == 'highlyCompensatedOfficerCompensation':
            obj_ = amountItemType.factory()
            obj_.build(child_)
            self.highlyCompensatedOfficerCompensation = obj_
            obj_.original_tagname_ = 'highlyCompensatedOfficerCompensation'
# end class highlyCompensatedOfficerComplexType


class identifierType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, scheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.scheme = _cast(None, scheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if identifierType.subclass:
            return identifierType.subclass(*args_, **kwargs_)
        else:
            return identifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scheme(self): return self.scheme
    def set_scheme(self, scheme): self.scheme = scheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='identifierType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='identifierType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='identifierType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='identifierType'):
        if self.scheme is not None and 'scheme' not in already_processed:
            already_processed.add('scheme')
            outfile.write(' scheme=%s' % (quote_attrib(self.scheme), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='identifierType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scheme', node)
        if value is not None and 'scheme' not in already_processed:
            already_processed.add('scheme')
            self.scheme = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class identifierType


class foreverType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if foreverType.subclass:
            return foreverType.subclass(*args_, **kwargs_)
        else:
            return foreverType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='foreverType', namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='foreverType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='foreverType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='foreverType'):
        pass
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='foreverType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class foreverType


class arcroleRef(simpleType):
    """Definition of the roleRef element - used to link to resolve
    xlink:arcrole attribute values to the arcroleType element
    declaration. This attribute contains the arc role name."""
    subclass = None
    superclass = simpleType
    def __init__(self, show=None, title=None, actuate=None, href=None, role=None, arcrole=None, type_=None, arcroleURI=None):
        self.original_tagname_ = None
        super(arcroleRef, self).__init__(show, title, actuate, href, role, arcrole, type_, )
        self.arcroleURI = _cast(None, arcroleURI)
    def factory(*args_, **kwargs_):
        if arcroleRef.subclass:
            return arcroleRef.subclass(*args_, **kwargs_)
        else:
            return arcroleRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_arcroleURI(self): return self.arcroleURI
    def set_arcroleURI(self, arcroleURI): self.arcroleURI = arcroleURI
    def hasContent_(self):
        if (
            super(arcroleRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='arcroleRef', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='arcroleRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='arcroleRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='arcroleRef'):
        super(arcroleRef, self).exportAttributes(outfile, level, already_processed, namespace_, name_='arcroleRef')
        if self.arcroleURI is not None and 'arcroleURI' not in already_processed:
            already_processed.add('arcroleURI')
            outfile.write(' arcroleURI=%s' % (quote_attrib(self.arcroleURI), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='arcroleRef', fromsubclass_=False, pretty_print=True):
        super(arcroleRef, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('arcroleURI', node)
        if value is not None and 'arcroleURI' not in already_processed:
            already_processed.add('arcroleURI')
            self.arcroleURI = value
        super(arcroleRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(arcroleRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class arcroleRef


class roleRef(simpleType):
    """Definition of the roleRef element - used to link to resolve
    xlink:role attribute values to the roleType element declaration.
    This attribute contains the role name."""
    subclass = None
    superclass = simpleType
    def __init__(self, show=None, title=None, actuate=None, href=None, role=None, arcrole=None, type_=None, roleURI=None):
        self.original_tagname_ = None
        super(roleRef, self).__init__(show, title, actuate, href, role, arcrole, type_, )
        self.roleURI = _cast(None, roleURI)
    def factory(*args_, **kwargs_):
        if roleRef.subclass:
            return roleRef.subclass(*args_, **kwargs_)
        else:
            return roleRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_roleURI(self): return self.roleURI
    def set_roleURI(self, roleURI): self.roleURI = roleURI
    def hasContent_(self):
        if (
            super(roleRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='roleRef', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='roleRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='roleRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='roleRef'):
        super(roleRef, self).exportAttributes(outfile, level, already_processed, namespace_, name_='roleRef')
        if self.roleURI is not None and 'roleURI' not in already_processed:
            already_processed.add('roleURI')
            outfile.write(' roleURI=%s' % (quote_attrib(self.roleURI), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='roleRef', fromsubclass_=False, pretty_print=True):
        super(roleRef, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('roleURI', node)
        if value is not None and 'roleURI' not in already_processed:
            already_processed.add('roleURI')
            self.roleURI = value
        super(roleRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(roleRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class roleRef


class footnote(resourceType):
    """Definition of the reference resource element"""
    subclass = None
    superclass = resourceType
    def __init__(self, role=None, title=None, type_=None, id=None, label=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(footnote, self).__init__(role, title, type_, id, label, valueOf_, mixedclass_, content_, )
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if footnote.subclass:
            return footnote.subclass(*args_, **kwargs_)
        else:
            return footnote(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_ or
            super(footnote, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='footnote', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='footnote')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='footnote', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='footnote'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(footnote, self).exportAttributes(outfile, level, already_processed, namespace_, name_='footnote')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='footnote', fromsubclass_=False, pretty_print=True):
        super(footnote, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(footnote, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(footnote, self).buildChildren(child_, node, nodeName_, True)
# end class footnote


class reference(resourceType):
    """Definition of the reference resource element."""
    subclass = None
    superclass = resourceType
    def __init__(self, role=None, title=None, type_=None, id=None, label=None, part=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(reference, self).__init__(role, title, type_, id, label, valueOf_, mixedclass_, content_, )
        if part is None:
            self.part = []
        else:
            self.part = part
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if reference.subclass:
            return reference.subclass(*args_, **kwargs_)
        else:
            return reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_part(self): return self.part
    def set_part(self, part): self.part = part
    def add_part(self, value): self.part.append(value)
    def insert_part_at(self, index, value): self.part.insert(index, value)
    def replace_part_at(self, index, value): self.part[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.part or
            self.valueOf_ or
            super(reference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='reference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='reference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='reference'):
        super(reference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='reference')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='reference', fromsubclass_=False, pretty_print=True):
        super(reference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(reference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'part' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'part', valuestr_)
            self.content_.append(obj_)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(reference, self).buildChildren(child_, node, nodeName_, True)
# end class reference


class label(resourceType):
    """Definition of the label resource element."""
    subclass = None
    superclass = resourceType
    def __init__(self, role=None, title=None, type_=None, id=None, label=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(label, self).__init__(role, title, type_, id, label, valueOf_, mixedclass_, content_, )
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if label.subclass:
            return label.subclass(*args_, **kwargs_)
        else:
            return label(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_ or
            super(label, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='label', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='label')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='label', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='label'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(label, self).exportAttributes(outfile, level, already_processed, namespace_, name_='label')
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='label', fromsubclass_=False, pretty_print=True):
        super(label, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(label, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(label, self).buildChildren(child_, node, nodeName_, True)
# end class label


class calculationArc(arcType):
    """Extension of the extended link arc type for calculation arcs. Adds a
    weight attribute to track weights on contributions to
    summations."""
    subclass = None
    superclass = arcType
    def __init__(self, use=None, from_=None, title_attr=None, show=None, arcrole=None, actuate=None, priority=None, to=None, type_=None, order=None, title=None, weight=None):
        self.original_tagname_ = None
        super(calculationArc, self).__init__(use, from_, title_attr, show, arcrole, actuate, priority, to, type_, order, title, )
        self.weight = _cast(None, weight)
    def factory(*args_, **kwargs_):
        if calculationArc.subclass:
            return calculationArc.subclass(*args_, **kwargs_)
        else:
            return calculationArc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def hasContent_(self):
        if (
            super(calculationArc, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='calculationArc', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='calculationArc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='calculationArc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='calculationArc'):
        super(calculationArc, self).exportAttributes(outfile, level, already_processed, namespace_, name_='calculationArc')
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight=%s' % (quote_attrib(self.weight), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='calculationArc', fromsubclass_=False, pretty_print=True):
        super(calculationArc, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            self.weight = value
        super(calculationArc, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(calculationArc, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class calculationArc


class presentationArc(arcType):
    """Extension of the extended link arc type for presentation arcs. Adds
    a preferredLabel attribute that documents the role attribute
    value of preferred labels (as they occur in label extended
    links)."""
    subclass = None
    superclass = arcType
    def __init__(self, use=None, from_=None, title_attr=None, show=None, arcrole=None, actuate=None, priority=None, to=None, type_=None, order=None, title=None, preferredLabel=None):
        self.original_tagname_ = None
        super(presentationArc, self).__init__(use, from_, title_attr, show, arcrole, actuate, priority, to, type_, order, title, )
        self.preferredLabel = _cast(None, preferredLabel)
    def factory(*args_, **kwargs_):
        if presentationArc.subclass:
            return presentationArc.subclass(*args_, **kwargs_)
        else:
            return presentationArc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_preferredLabel(self): return self.preferredLabel
    def set_preferredLabel(self, preferredLabel): self.preferredLabel = preferredLabel
    def hasContent_(self):
        if (
            super(presentationArc, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='finassist:', name_='presentationArc', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='presentationArc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='finassist:', name_='presentationArc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='finassist:', name_='presentationArc'):
        super(presentationArc, self).exportAttributes(outfile, level, already_processed, namespace_, name_='presentationArc')
        if self.preferredLabel is not None and 'preferredLabel' not in already_processed:
            already_processed.add('preferredLabel')
            outfile.write(' preferredLabel=%s' % (quote_attrib(self.preferredLabel), ))
    def exportChildren(self, outfile, level, namespace_='finassist:', name_='presentationArc', fromsubclass_=False, pretty_print=True):
        super(presentationArc, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('preferredLabel', node)
        if value is not None and 'preferredLabel' not in already_processed:
            already_processed.add('preferredLabel')
            self.preferredLabel = value
        super(presentationArc, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(presentationArc, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class presentationArc


GDSClassesMapping = {
    'federalFundingAmount': amountItemType,
    'catalogOfFederalDomesticAssistanceProgram': catalogOfFederalDomesticAssistanceProgramComplexType,
    'periodOfPerformancePotentialEndDate': dateItemType,
    'treasuryAccountSymbol': TreasuryAccountSymbolComplexType,
    'labelArc': arcType,
    'awardeeInformation': awardeeInformationComplexType,
    'simple': simpleType,
    'highlyCompensatedOfficerFirstName': stringItemType,
    'referenceArc': arcType,
    'entity': contextEntityType,
    'county': stringItemType,
    'locator': locatorType,
    'arc': arcType,
    'awardDescription': stringItemType,
    'highlyCompensatedOfficerLastName': stringItemType,
    'awardeeAddress': addressComplexType,
    'highlyCompensatedOfficer': highlyCompensatedOfficerComplexType,
    'schemaRef': simpleType,
    'loc': locatorType,
    'ultimateParentUniqueIdentifier': integerItemType,
    'awardeeUniqueIdentifierSupplemental': stringItemType,
    'unitDenominator': measuresType,
    'mainAccountNumber': integerItemType,
    'title': titleType,
    'typeOfTransactionCode': typeOfTransactionCodeItemType,
    'recordType': recordTypeItemType,
    'fundingSubTierAgency': agencyComplexType,
    'agency': agencyComplexType,
    'availabilityTypeCode': availableTypeCodeItemType,
    'awardeeUniqueIdentifier': integerItemType,
    'countryCode': stringItemType,
    'modificationAmendmentNumber': stringItemType,
    'streetAddress': streetAddressComplexType,
    'subAccountSymbol': integerItemType,
    'streetAddressLine': stringItemType,
    'postalCode': stringItemType,
    'awardingSubTierAgency': agencyComplexType,
    'catalogOfFederalDomesticAssistanceTitle': stringItemType,
    'awardeeLegalBusinessName': stringItemType,
    'congressionalDistrict': congressionalDistrictItemType,
    'periodOfPerformanceCurrentEndDate': dateItemType,
    'officeIdentifier': integerItemType,
    'businessType': businessTypeItemType,
    'extended': extendedType,
    'periodOfPerformance': periodOfPerformanceComplexType,
    'unitNumerator': measuresType,
    'city': stringItemType,
    'officeName': stringItemType,
    'awardingAgency': agencyComplexType,
    'highlyCompensatedOfficerMiddleInitial': stringItemType,
    'award': awardComplexType,
    'period': contextPeriodType,
    'countryName': stringItemType,
    'ultimateParentLegalBusinessName': stringItemType,
    'awardAmounts': awardAmountsComplexType,
    'state': stateItemType,
    'agencyOffice': agencyOfficeComplexType,
    'periodOfPerformanceStartDate': dateItemType,
    'address': addressComplexType,
    'periodOfPerformanceActionDate': dateItemType,
    'primaryPlaceOfPerformance': addressComplexType,
    'nonFederalFundingAmount': amountItemType,
    'beginningPeriodOfAvailability': stringItemType,
    'typeOfAction': typeOfActionItemType,
    'fundingAgency': agencyComplexType,
    'forever': foreverType,
    'identifier': identifierType,
    'resource': resourceType,
    'agencyName': stringItemType,
    'scenario': contextScenarioType,
    'parentAwardID': stringItemType,
    'endingPeriodOfAvailability': stringItemType,
    'allocationTransferAgencyIdentifier': integerItemType,
    'zipCodePlus4': stringItemType,
    'documentation': documentationType,
    'highlyCompensatedOfficerCompensation': amountItemType,
    'catalogOfFederalDomesticAssistanceNumber': stringItemType,
    'totalFundingAmount': amountItemType,
    'agencyIdentifier': integerItemType,
    'awardID': stringItemType,
    'definitionArc': arcType,
    'footnoteArc': arcType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'awardComplexType'
        rootClass = awardComplexType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'awardComplexType'
        rootClass = awardComplexType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'awardComplexType'
        rootClass = awardComplexType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:finassist="http://www.xbrl.org/int/finassist/2006-10-25"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'awardComplexType'
        rootClass = awardComplexType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from finassist import *\n\n')
        sys.stdout.write('import finassist as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "NCNameItemType",
    "NameItemType",
    "QNameItemType",
    "TreasuryAccountSymbolComplexType",
    "accountPurposeCodeItemType",
    "accountTypeItemType",
    "addressComplexType",
    "agencyComplexType",
    "agencyOfficeComplexType",
    "amountItemType",
    "anyURIItemType",
    "arcType",
    "arcroleRef",
    "arcroleType",
    "availableTypeCodeItemType",
    "awardAmountsComplexType",
    "awardComplexType",
    "awardeeInformationComplexType",
    "base64BinaryItemType",
    "bookTaxDifferenceItemType",
    "booleanItemType",
    "businessTypeItemType",
    "byteItemType",
    "calculationArc",
    "calculationLink",
    "catalogOfFederalDomesticAssistanceProgramComplexType",
    "congressionalDistrictItemType",
    "context",
    "contextEntityType",
    "contextPeriodType",
    "contextScenarioType",
    "dateItemType",
    "dateTimeItemType",
    "debitCreditCodeItemType",
    "decimalItemType",
    "definitionLink",
    "divide",
    "documentTypeItemType",
    "documentationType",
    "doubleItemType",
    "durationItemType",
    "entriesTypeItemType",
    "entryTypeItemType",
    "extendedType",
    "floatItemType",
    "footnote",
    "footnoteLink",
    "foreverType",
    "fractionItemType",
    "gDayItemType",
    "gMonthDayItemType",
    "gMonthItemType",
    "gYearItemType",
    "gYearMonthItemType",
    "hexBinaryItemType",
    "highlyCompensatedOfficerComplexType",
    "identifierOrganizationTypeItemType",
    "identifierType",
    "identifierTypeItemType",
    "intItemType",
    "integerItemType",
    "invoiceTypeItemType",
    "label",
    "labelLink",
    "languageItemType",
    "linkbase",
    "linkbaseRef",
    "locatorType",
    "longItemType",
    "mainAccountTypeItemType",
    "measuresType",
    "monetaryItemType",
    "negativeIntegerItemType",
    "nonNegativeIntegerItemType",
    "nonPositiveIntegerItemType",
    "normalizedStringItemType",
    "periodOfPerformanceComplexType",
    "phoneNumberDescriptionItemType",
    "positiveIntegerItemType",
    "postingStatusItemType",
    "presentationArc",
    "presentationLink",
    "pureItemType",
    "qualifierEntryItemType",
    "recordTypeItemType",
    "reference",
    "referenceLink",
    "resourceType",
    "revisesUniqueIDActionItemType",
    "roleRef",
    "roleType",
    "segment",
    "sharesItemType",
    "shortItemType",
    "signOfAmountItemType",
    "simpleType",
    "sourceJournalIDItemType",
    "stateItemType",
    "streetAddressComplexType",
    "stringItemType",
    "timeItemType",
    "titleType",
    "tokenItemType",
    "typeOfActionItemType",
    "typeOfTransactionCodeItemType",
    "unit",
    "unsignedByteItemType",
    "unsignedIntItemType",
    "unsignedLongItemType",
    "unsignedShortItemType",
    "xbrl",
    "xbrlIncludeItemType"
]
